"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolI_ToAmino = exports.PoolI_FromAmino = exports.PoolI_InterfaceDecoder = exports.AccumObject = exports.GenesisState = exports.PositionData = exports.PoolData = exports.FullTick = void 0;
const tickInfo_1 = require("./tickInfo");
const any_1 = require("../../google/protobuf/any");
const incentive_record_1 = require("./incentive_record");
const position_1 = require("./position");
const accum_1 = require("../accum/v1beta1/accum");
const params_1 = require("./params");
const pool_1 = require("./pool");
const pool_2 = require("../cosmwasmpool/v1beta1/model/pool");
const balancerPool_1 = require("../gamm/pool-models/balancer/balancerPool");
const stableswap_pool_1 = require("../gamm/pool-models/stableswap/stableswap_pool");
const binary_1 = require("../../binary");
function createBaseFullTick() {
    return {
        poolId: BigInt(0),
        tickIndex: BigInt(0),
        info: tickInfo_1.TickInfo.fromPartial({})
    };
}
exports.FullTick = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.FullTick",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tickIndex !== BigInt(0)) {
            writer.uint32(16).int64(message.tickIndex);
        }
        if (message.info !== undefined) {
            tickInfo_1.TickInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullTick();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tickIndex = reader.int64();
                    break;
                case 3:
                    message.info = tickInfo_1.TickInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseFullTick();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tickIndex = object.tickIndex !== undefined && object.tickIndex !== null ? BigInt(object.tickIndex.toString()) : BigInt(0);
        message.info = object.info !== undefined && object.info !== null ? tickInfo_1.TickInfo.fromPartial(object.info) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tickIndex: BigInt(object.tick_index),
            info: object?.info ? tickInfo_1.TickInfo.fromAmino(object.info) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.tick_index = message.tickIndex ? message.tickIndex.toString() : undefined;
        obj.info = message.info ? tickInfo_1.TickInfo.toAmino(message.info) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.FullTick.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/full-tick",
            value: exports.FullTick.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.FullTick.decode(message.value);
    },
    toProto(message) {
        return exports.FullTick.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.FullTick",
            value: exports.FullTick.encode(message).finish()
        };
    }
};
function createBasePoolData() {
    return {
        pool: undefined,
        ticks: [],
        spreadRewardAccumulator: exports.AccumObject.fromPartial({}),
        incentivesAccumulators: [],
        incentiveRecords: []
    };
}
exports.PoolData = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolData",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pool !== undefined) {
            any_1.Any.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.ticks) {
            exports.FullTick.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.spreadRewardAccumulator !== undefined) {
            exports.AccumObject.encode(message.spreadRewardAccumulator, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.incentivesAccumulators) {
            exports.AccumObject.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.incentiveRecords) {
            incentive_record_1.IncentiveRecord.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = (0, exports.PoolI_InterfaceDecoder)(reader);
                    break;
                case 2:
                    message.ticks.push(exports.FullTick.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.spreadRewardAccumulator = exports.AccumObject.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.incentivesAccumulators.push(exports.AccumObject.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.incentiveRecords.push(incentive_record_1.IncentiveRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolData();
        message.pool = object.pool !== undefined && object.pool !== null ? any_1.Any.fromPartial(object.pool) : undefined;
        message.ticks = object.ticks?.map(e => exports.FullTick.fromPartial(e)) || [];
        message.spreadRewardAccumulator = object.spreadRewardAccumulator !== undefined && object.spreadRewardAccumulator !== null ? exports.AccumObject.fromPartial(object.spreadRewardAccumulator) : undefined;
        message.incentivesAccumulators = object.incentivesAccumulators?.map(e => exports.AccumObject.fromPartial(e)) || [];
        message.incentiveRecords = object.incentiveRecords?.map(e => incentive_record_1.IncentiveRecord.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            pool: object?.pool ? (0, exports.PoolI_FromAmino)(object.pool) : undefined,
            ticks: Array.isArray(object?.ticks) ? object.ticks.map((e) => exports.FullTick.fromAmino(e)) : [],
            spreadRewardAccumulator: object?.spread_reward_accumulator ? exports.AccumObject.fromAmino(object.spread_reward_accumulator) : undefined,
            incentivesAccumulators: Array.isArray(object?.incentives_accumulators) ? object.incentives_accumulators.map((e) => exports.AccumObject.fromAmino(e)) : [],
            incentiveRecords: Array.isArray(object?.incentive_records) ? object.incentive_records.map((e) => incentive_record_1.IncentiveRecord.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool = message.pool ? (0, exports.PoolI_ToAmino)(message.pool) : undefined;
        if (message.ticks) {
            obj.ticks = message.ticks.map(e => e ? exports.FullTick.toAmino(e) : undefined);
        }
        else {
            obj.ticks = [];
        }
        obj.spread_reward_accumulator = message.spreadRewardAccumulator ? exports.AccumObject.toAmino(message.spreadRewardAccumulator) : undefined;
        if (message.incentivesAccumulators) {
            obj.incentives_accumulators = message.incentivesAccumulators.map(e => e ? exports.AccumObject.toAmino(e) : undefined);
        }
        else {
            obj.incentives_accumulators = [];
        }
        if (message.incentiveRecords) {
            obj.incentive_records = message.incentiveRecords.map(e => e ? incentive_record_1.IncentiveRecord.toAmino(e) : undefined);
        }
        else {
            obj.incentive_records = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PoolData.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pool-data",
            value: exports.PoolData.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PoolData.decode(message.value);
    },
    toProto(message) {
        return exports.PoolData.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolData",
            value: exports.PoolData.encode(message).finish()
        };
    }
};
function createBasePositionData() {
    return {
        position: position_1.Position.fromPartial({}),
        lockId: BigInt(0),
        spreadRewardAccumRecord: accum_1.Record.fromPartial({}),
        uptimeAccumRecords: []
    };
}
exports.PositionData = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionData",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.position !== undefined) {
            position_1.Position.encode(message.position, writer.uint32(10).fork()).ldelim();
        }
        if (message.lockId !== BigInt(0)) {
            writer.uint32(16).uint64(message.lockId);
        }
        if (message.spreadRewardAccumRecord !== undefined) {
            accum_1.Record.encode(message.spreadRewardAccumRecord, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.uptimeAccumRecords) {
            accum_1.Record.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.position = position_1.Position.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.lockId = reader.uint64();
                    break;
                case 3:
                    message.spreadRewardAccumRecord = accum_1.Record.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.uptimeAccumRecords.push(accum_1.Record.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePositionData();
        message.position = object.position !== undefined && object.position !== null ? position_1.Position.fromPartial(object.position) : undefined;
        message.lockId = object.lockId !== undefined && object.lockId !== null ? BigInt(object.lockId.toString()) : BigInt(0);
        message.spreadRewardAccumRecord = object.spreadRewardAccumRecord !== undefined && object.spreadRewardAccumRecord !== null ? accum_1.Record.fromPartial(object.spreadRewardAccumRecord) : undefined;
        message.uptimeAccumRecords = object.uptimeAccumRecords?.map(e => accum_1.Record.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            position: object?.position ? position_1.Position.fromAmino(object.position) : undefined,
            lockId: BigInt(object.lock_id),
            spreadRewardAccumRecord: object?.spread_reward_accum_record ? accum_1.Record.fromAmino(object.spread_reward_accum_record) : undefined,
            uptimeAccumRecords: Array.isArray(object?.uptime_accum_records) ? object.uptime_accum_records.map((e) => accum_1.Record.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position = message.position ? position_1.Position.toAmino(message.position) : undefined;
        obj.lock_id = message.lockId ? message.lockId.toString() : undefined;
        obj.spread_reward_accum_record = message.spreadRewardAccumRecord ? accum_1.Record.toAmino(message.spreadRewardAccumRecord) : undefined;
        if (message.uptimeAccumRecords) {
            obj.uptime_accum_records = message.uptimeAccumRecords.map(e => e ? accum_1.Record.toAmino(e) : undefined);
        }
        else {
            obj.uptime_accum_records = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PositionData.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/position-data",
            value: exports.PositionData.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PositionData.decode(message.value);
    },
    toProto(message) {
        return exports.PositionData.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionData",
            value: exports.PositionData.encode(message).finish()
        };
    }
};
function createBaseGenesisState() {
    return {
        params: params_1.Params.fromPartial({}),
        poolData: [],
        positionData: [],
        nextPositionId: BigInt(0),
        nextIncentiveRecordId: BigInt(0)
    };
}
exports.GenesisState = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.GenesisState",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) {
            params_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.poolData) {
            exports.PoolData.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.positionData) {
            exports.PositionData.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.nextPositionId !== BigInt(0)) {
            writer.uint32(32).uint64(message.nextPositionId);
        }
        if (message.nextIncentiveRecordId !== BigInt(0)) {
            writer.uint32(40).uint64(message.nextIncentiveRecordId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenesisState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = params_1.Params.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.poolData.push(exports.PoolData.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.positionData.push(exports.PositionData.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.nextPositionId = reader.uint64();
                    break;
                case 5:
                    message.nextIncentiveRecordId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGenesisState();
        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
        message.poolData = object.poolData?.map(e => exports.PoolData.fromPartial(e)) || [];
        message.positionData = object.positionData?.map(e => exports.PositionData.fromPartial(e)) || [];
        message.nextPositionId = object.nextPositionId !== undefined && object.nextPositionId !== null ? BigInt(object.nextPositionId.toString()) : BigInt(0);
        message.nextIncentiveRecordId = object.nextIncentiveRecordId !== undefined && object.nextIncentiveRecordId !== null ? BigInt(object.nextIncentiveRecordId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            params: object?.params ? params_1.Params.fromAmino(object.params) : undefined,
            poolData: Array.isArray(object?.pool_data) ? object.pool_data.map((e) => exports.PoolData.fromAmino(e)) : [],
            positionData: Array.isArray(object?.position_data) ? object.position_data.map((e) => exports.PositionData.fromAmino(e)) : [],
            nextPositionId: BigInt(object.next_position_id),
            nextIncentiveRecordId: BigInt(object.next_incentive_record_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.params = message.params ? params_1.Params.toAmino(message.params) : undefined;
        if (message.poolData) {
            obj.pool_data = message.poolData.map(e => e ? exports.PoolData.toAmino(e) : undefined);
        }
        else {
            obj.pool_data = [];
        }
        if (message.positionData) {
            obj.position_data = message.positionData.map(e => e ? exports.PositionData.toAmino(e) : undefined);
        }
        else {
            obj.position_data = [];
        }
        obj.next_position_id = message.nextPositionId ? message.nextPositionId.toString() : undefined;
        obj.next_incentive_record_id = message.nextIncentiveRecordId ? message.nextIncentiveRecordId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.GenesisState.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/genesis-state",
            value: exports.GenesisState.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.GenesisState.decode(message.value);
    },
    toProto(message) {
        return exports.GenesisState.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.GenesisState",
            value: exports.GenesisState.encode(message).finish()
        };
    }
};
function createBaseAccumObject() {
    return {
        name: "",
        accumContent: accum_1.AccumulatorContent.fromPartial({})
    };
}
exports.AccumObject = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.AccumObject",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.accumContent !== undefined) {
            accum_1.AccumulatorContent.encode(message.accumContent, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccumObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.accumContent = accum_1.AccumulatorContent.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseAccumObject();
        message.name = object.name ?? "";
        message.accumContent = object.accumContent !== undefined && object.accumContent !== null ? accum_1.AccumulatorContent.fromPartial(object.accumContent) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            name: object.name,
            accumContent: object?.accum_content ? accum_1.AccumulatorContent.fromAmino(object.accum_content) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.name = message.name;
        obj.accum_content = message.accumContent ? accum_1.AccumulatorContent.toAmino(message.accumContent) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.AccumObject.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/accum-object",
            value: exports.AccumObject.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.AccumObject.decode(message.value);
    },
    toProto(message) {
        return exports.AccumObject.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.AccumObject",
            value: exports.AccumObject.encode(message).finish()
        };
    }
};
const PoolI_InterfaceDecoder = (input) => {
    const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
    const data = any_1.Any.decode(reader, reader.uint32());
    switch (data.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return pool_1.Pool.decode(data.value);
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return pool_2.CosmWasmPool.decode(data.value);
        case "/osmosis.gamm.v1beta1.Pool":
            return balancerPool_1.Pool.decode(data.value);
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return stableswap_pool_1.Pool.decode(data.value);
        default:
            return data;
    }
};
exports.PoolI_InterfaceDecoder = PoolI_InterfaceDecoder;
const PoolI_FromAmino = (content) => {
    switch (content.type) {
        case "osmosis/concentratedliquidity/pool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.concentratedliquidity.v1beta1.Pool",
                value: pool_1.Pool.encode(pool_1.Pool.fromPartial(pool_1.Pool.fromAmino(content.value))).finish()
            });
        case "osmosis/cosmwasmpool/cosm-wasm-pool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool",
                value: pool_2.CosmWasmPool.encode(pool_2.CosmWasmPool.fromPartial(pool_2.CosmWasmPool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/BalancerPool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.gamm.v1beta1.Pool",
                value: balancerPool_1.Pool.encode(balancerPool_1.Pool.fromPartial(balancerPool_1.Pool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/StableswapPool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool",
                value: stableswap_pool_1.Pool.encode(stableswap_pool_1.Pool.fromPartial(stableswap_pool_1.Pool.fromAmino(content.value))).finish()
            });
        default:
            return any_1.Any.fromAmino(content);
    }
};
exports.PoolI_FromAmino = PoolI_FromAmino;
const PoolI_ToAmino = (content) => {
    switch (content.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return {
                type: "osmosis/concentratedliquidity/pool",
                value: pool_1.Pool.toAmino(pool_1.Pool.decode(content.value))
            };
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return {
                type: "osmosis/cosmwasmpool/cosm-wasm-pool",
                value: pool_2.CosmWasmPool.toAmino(pool_2.CosmWasmPool.decode(content.value))
            };
        case "/osmosis.gamm.v1beta1.Pool":
            return {
                type: "osmosis/gamm/BalancerPool",
                value: balancerPool_1.Pool.toAmino(balancerPool_1.Pool.decode(content.value))
            };
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return {
                type: "osmosis/gamm/StableswapPool",
                value: stableswap_pool_1.Pool.toAmino(stableswap_pool_1.Pool.decode(content.value))
            };
        default:
            return any_1.Any.toAmino(content);
    }
};
exports.PoolI_ToAmino = PoolI_ToAmino;
//# sourceMappingURL=genesis.js.map
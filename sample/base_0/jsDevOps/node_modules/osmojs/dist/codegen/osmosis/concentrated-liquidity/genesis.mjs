import { TickInfo } from "./tickInfo";
import { Any } from "../../google/protobuf/any";
import { IncentiveRecord } from "./incentive_record";
import { Position } from "./position";
import { Record, AccumulatorContent } from "../accum/v1beta1/accum";
import { Params } from "./params";
import { Pool as Pool1 } from "./pool";
import { CosmWasmPool } from "../cosmwasmpool/v1beta1/model/pool";
import { Pool as Pool2 } from "../gamm/pool-models/balancer/balancerPool";
import { Pool as Pool3 } from "../gamm/pool-models/stableswap/stableswap_pool";
import { BinaryReader, BinaryWriter } from "../../binary";
function createBaseFullTick() {
    return {
        poolId: BigInt(0),
        tickIndex: BigInt(0),
        info: TickInfo.fromPartial({})
    };
}
export const FullTick = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.FullTick",
    encode(message, writer = BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tickIndex !== BigInt(0)) {
            writer.uint32(16).int64(message.tickIndex);
        }
        if (message.info !== undefined) {
            TickInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullTick();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tickIndex = reader.int64();
                    break;
                case 3:
                    message.info = TickInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseFullTick();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tickIndex = object.tickIndex !== undefined && object.tickIndex !== null ? BigInt(object.tickIndex.toString()) : BigInt(0);
        message.info = object.info !== undefined && object.info !== null ? TickInfo.fromPartial(object.info) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tickIndex: BigInt(object.tick_index),
            info: object?.info ? TickInfo.fromAmino(object.info) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.tick_index = message.tickIndex ? message.tickIndex.toString() : undefined;
        obj.info = message.info ? TickInfo.toAmino(message.info) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return FullTick.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/full-tick",
            value: FullTick.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return FullTick.decode(message.value);
    },
    toProto(message) {
        return FullTick.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.FullTick",
            value: FullTick.encode(message).finish()
        };
    }
};
function createBasePoolData() {
    return {
        pool: undefined,
        ticks: [],
        spreadRewardAccumulator: AccumObject.fromPartial({}),
        incentivesAccumulators: [],
        incentiveRecords: []
    };
}
export const PoolData = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolData",
    encode(message, writer = BinaryWriter.create()) {
        if (message.pool !== undefined) {
            Any.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.ticks) {
            FullTick.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.spreadRewardAccumulator !== undefined) {
            AccumObject.encode(message.spreadRewardAccumulator, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.incentivesAccumulators) {
            AccumObject.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.incentiveRecords) {
            IncentiveRecord.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = PoolI_InterfaceDecoder(reader);
                    break;
                case 2:
                    message.ticks.push(FullTick.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.spreadRewardAccumulator = AccumObject.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.incentivesAccumulators.push(AccumObject.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.incentiveRecords.push(IncentiveRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolData();
        message.pool = object.pool !== undefined && object.pool !== null ? Any.fromPartial(object.pool) : undefined;
        message.ticks = object.ticks?.map(e => FullTick.fromPartial(e)) || [];
        message.spreadRewardAccumulator = object.spreadRewardAccumulator !== undefined && object.spreadRewardAccumulator !== null ? AccumObject.fromPartial(object.spreadRewardAccumulator) : undefined;
        message.incentivesAccumulators = object.incentivesAccumulators?.map(e => AccumObject.fromPartial(e)) || [];
        message.incentiveRecords = object.incentiveRecords?.map(e => IncentiveRecord.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            pool: object?.pool ? PoolI_FromAmino(object.pool) : undefined,
            ticks: Array.isArray(object?.ticks) ? object.ticks.map((e) => FullTick.fromAmino(e)) : [],
            spreadRewardAccumulator: object?.spread_reward_accumulator ? AccumObject.fromAmino(object.spread_reward_accumulator) : undefined,
            incentivesAccumulators: Array.isArray(object?.incentives_accumulators) ? object.incentives_accumulators.map((e) => AccumObject.fromAmino(e)) : [],
            incentiveRecords: Array.isArray(object?.incentive_records) ? object.incentive_records.map((e) => IncentiveRecord.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool = message.pool ? PoolI_ToAmino(message.pool) : undefined;
        if (message.ticks) {
            obj.ticks = message.ticks.map(e => e ? FullTick.toAmino(e) : undefined);
        }
        else {
            obj.ticks = [];
        }
        obj.spread_reward_accumulator = message.spreadRewardAccumulator ? AccumObject.toAmino(message.spreadRewardAccumulator) : undefined;
        if (message.incentivesAccumulators) {
            obj.incentives_accumulators = message.incentivesAccumulators.map(e => e ? AccumObject.toAmino(e) : undefined);
        }
        else {
            obj.incentives_accumulators = [];
        }
        if (message.incentiveRecords) {
            obj.incentive_records = message.incentiveRecords.map(e => e ? IncentiveRecord.toAmino(e) : undefined);
        }
        else {
            obj.incentive_records = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return PoolData.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pool-data",
            value: PoolData.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PoolData.decode(message.value);
    },
    toProto(message) {
        return PoolData.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolData",
            value: PoolData.encode(message).finish()
        };
    }
};
function createBasePositionData() {
    return {
        position: Position.fromPartial({}),
        lockId: BigInt(0),
        spreadRewardAccumRecord: Record.fromPartial({}),
        uptimeAccumRecords: []
    };
}
export const PositionData = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionData",
    encode(message, writer = BinaryWriter.create()) {
        if (message.position !== undefined) {
            Position.encode(message.position, writer.uint32(10).fork()).ldelim();
        }
        if (message.lockId !== BigInt(0)) {
            writer.uint32(16).uint64(message.lockId);
        }
        if (message.spreadRewardAccumRecord !== undefined) {
            Record.encode(message.spreadRewardAccumRecord, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.uptimeAccumRecords) {
            Record.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.position = Position.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.lockId = reader.uint64();
                    break;
                case 3:
                    message.spreadRewardAccumRecord = Record.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.uptimeAccumRecords.push(Record.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePositionData();
        message.position = object.position !== undefined && object.position !== null ? Position.fromPartial(object.position) : undefined;
        message.lockId = object.lockId !== undefined && object.lockId !== null ? BigInt(object.lockId.toString()) : BigInt(0);
        message.spreadRewardAccumRecord = object.spreadRewardAccumRecord !== undefined && object.spreadRewardAccumRecord !== null ? Record.fromPartial(object.spreadRewardAccumRecord) : undefined;
        message.uptimeAccumRecords = object.uptimeAccumRecords?.map(e => Record.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            position: object?.position ? Position.fromAmino(object.position) : undefined,
            lockId: BigInt(object.lock_id),
            spreadRewardAccumRecord: object?.spread_reward_accum_record ? Record.fromAmino(object.spread_reward_accum_record) : undefined,
            uptimeAccumRecords: Array.isArray(object?.uptime_accum_records) ? object.uptime_accum_records.map((e) => Record.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position = message.position ? Position.toAmino(message.position) : undefined;
        obj.lock_id = message.lockId ? message.lockId.toString() : undefined;
        obj.spread_reward_accum_record = message.spreadRewardAccumRecord ? Record.toAmino(message.spreadRewardAccumRecord) : undefined;
        if (message.uptimeAccumRecords) {
            obj.uptime_accum_records = message.uptimeAccumRecords.map(e => e ? Record.toAmino(e) : undefined);
        }
        else {
            obj.uptime_accum_records = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return PositionData.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/position-data",
            value: PositionData.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PositionData.decode(message.value);
    },
    toProto(message) {
        return PositionData.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionData",
            value: PositionData.encode(message).finish()
        };
    }
};
function createBaseGenesisState() {
    return {
        params: Params.fromPartial({}),
        poolData: [],
        positionData: [],
        nextPositionId: BigInt(0),
        nextIncentiveRecordId: BigInt(0)
    };
}
export const GenesisState = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.GenesisState",
    encode(message, writer = BinaryWriter.create()) {
        if (message.params !== undefined) {
            Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.poolData) {
            PoolData.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.positionData) {
            PositionData.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.nextPositionId !== BigInt(0)) {
            writer.uint32(32).uint64(message.nextPositionId);
        }
        if (message.nextIncentiveRecordId !== BigInt(0)) {
            writer.uint32(40).uint64(message.nextIncentiveRecordId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenesisState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = Params.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.poolData.push(PoolData.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.positionData.push(PositionData.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.nextPositionId = reader.uint64();
                    break;
                case 5:
                    message.nextIncentiveRecordId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGenesisState();
        message.params = object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
        message.poolData = object.poolData?.map(e => PoolData.fromPartial(e)) || [];
        message.positionData = object.positionData?.map(e => PositionData.fromPartial(e)) || [];
        message.nextPositionId = object.nextPositionId !== undefined && object.nextPositionId !== null ? BigInt(object.nextPositionId.toString()) : BigInt(0);
        message.nextIncentiveRecordId = object.nextIncentiveRecordId !== undefined && object.nextIncentiveRecordId !== null ? BigInt(object.nextIncentiveRecordId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            params: object?.params ? Params.fromAmino(object.params) : undefined,
            poolData: Array.isArray(object?.pool_data) ? object.pool_data.map((e) => PoolData.fromAmino(e)) : [],
            positionData: Array.isArray(object?.position_data) ? object.position_data.map((e) => PositionData.fromAmino(e)) : [],
            nextPositionId: BigInt(object.next_position_id),
            nextIncentiveRecordId: BigInt(object.next_incentive_record_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.params = message.params ? Params.toAmino(message.params) : undefined;
        if (message.poolData) {
            obj.pool_data = message.poolData.map(e => e ? PoolData.toAmino(e) : undefined);
        }
        else {
            obj.pool_data = [];
        }
        if (message.positionData) {
            obj.position_data = message.positionData.map(e => e ? PositionData.toAmino(e) : undefined);
        }
        else {
            obj.position_data = [];
        }
        obj.next_position_id = message.nextPositionId ? message.nextPositionId.toString() : undefined;
        obj.next_incentive_record_id = message.nextIncentiveRecordId ? message.nextIncentiveRecordId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return GenesisState.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/genesis-state",
            value: GenesisState.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GenesisState.decode(message.value);
    },
    toProto(message) {
        return GenesisState.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.GenesisState",
            value: GenesisState.encode(message).finish()
        };
    }
};
function createBaseAccumObject() {
    return {
        name: "",
        accumContent: AccumulatorContent.fromPartial({})
    };
}
export const AccumObject = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.AccumObject",
    encode(message, writer = BinaryWriter.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.accumContent !== undefined) {
            AccumulatorContent.encode(message.accumContent, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccumObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.accumContent = AccumulatorContent.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseAccumObject();
        message.name = object.name ?? "";
        message.accumContent = object.accumContent !== undefined && object.accumContent !== null ? AccumulatorContent.fromPartial(object.accumContent) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            name: object.name,
            accumContent: object?.accum_content ? AccumulatorContent.fromAmino(object.accum_content) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.name = message.name;
        obj.accum_content = message.accumContent ? AccumulatorContent.toAmino(message.accumContent) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return AccumObject.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/accum-object",
            value: AccumObject.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return AccumObject.decode(message.value);
    },
    toProto(message) {
        return AccumObject.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.AccumObject",
            value: AccumObject.encode(message).finish()
        };
    }
};
export const PoolI_InterfaceDecoder = (input) => {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const data = Any.decode(reader, reader.uint32());
    switch (data.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return Pool1.decode(data.value);
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return CosmWasmPool.decode(data.value);
        case "/osmosis.gamm.v1beta1.Pool":
            return Pool2.decode(data.value);
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return Pool3.decode(data.value);
        default:
            return data;
    }
};
export const PoolI_FromAmino = (content) => {
    switch (content.type) {
        case "osmosis/concentratedliquidity/pool":
            return Any.fromPartial({
                typeUrl: "/osmosis.concentratedliquidity.v1beta1.Pool",
                value: Pool1.encode(Pool1.fromPartial(Pool1.fromAmino(content.value))).finish()
            });
        case "osmosis/cosmwasmpool/cosm-wasm-pool":
            return Any.fromPartial({
                typeUrl: "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool",
                value: CosmWasmPool.encode(CosmWasmPool.fromPartial(CosmWasmPool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/BalancerPool":
            return Any.fromPartial({
                typeUrl: "/osmosis.gamm.v1beta1.Pool",
                value: Pool2.encode(Pool2.fromPartial(Pool2.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/StableswapPool":
            return Any.fromPartial({
                typeUrl: "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool",
                value: Pool3.encode(Pool3.fromPartial(Pool3.fromAmino(content.value))).finish()
            });
        default:
            return Any.fromAmino(content);
    }
};
export const PoolI_ToAmino = (content) => {
    switch (content.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return {
                type: "osmosis/concentratedliquidity/pool",
                value: Pool1.toAmino(Pool1.decode(content.value))
            };
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return {
                type: "osmosis/cosmwasmpool/cosm-wasm-pool",
                value: CosmWasmPool.toAmino(CosmWasmPool.decode(content.value))
            };
        case "/osmosis.gamm.v1beta1.Pool":
            return {
                type: "osmosis/gamm/BalancerPool",
                value: Pool2.toAmino(Pool2.decode(content.value))
            };
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return {
                type: "osmosis/gamm/StableswapPool",
                value: Pool3.toAmino(Pool3.decode(content.value))
            };
        default:
            return Any.toAmino(content);
    }
};
//# sourceMappingURL=genesis.js.map
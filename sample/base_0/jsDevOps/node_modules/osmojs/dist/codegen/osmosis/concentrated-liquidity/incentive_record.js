"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IncentiveRecordBody = exports.IncentiveRecord = void 0;
const duration_1 = require("../../google/protobuf/duration");
const coin_1 = require("../../cosmos/base/v1beta1/coin");
const timestamp_1 = require("../../google/protobuf/timestamp");
const binary_1 = require("../../binary");
const math_1 = require("@cosmjs/math");
const helpers_1 = require("../../helpers");
function createBaseIncentiveRecord() {
    return {
        incentiveId: BigInt(0),
        poolId: BigInt(0),
        incentiveRecordBody: exports.IncentiveRecordBody.fromPartial({}),
        minUptime: undefined
    };
}
exports.IncentiveRecord = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecord",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.incentiveId !== BigInt(0)) {
            writer.uint32(8).uint64(message.incentiveId);
        }
        if (message.poolId !== BigInt(0)) {
            writer.uint32(16).uint64(message.poolId);
        }
        if (message.incentiveRecordBody !== undefined) {
            exports.IncentiveRecordBody.encode(message.incentiveRecordBody, writer.uint32(34).fork()).ldelim();
        }
        if (message.minUptime !== undefined) {
            duration_1.Duration.encode(message.minUptime, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.incentiveId = reader.uint64();
                    break;
                case 2:
                    message.poolId = reader.uint64();
                    break;
                case 4:
                    message.incentiveRecordBody = exports.IncentiveRecordBody.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.minUptime = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecord();
        message.incentiveId = object.incentiveId !== undefined && object.incentiveId !== null ? BigInt(object.incentiveId.toString()) : BigInt(0);
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.incentiveRecordBody = object.incentiveRecordBody !== undefined && object.incentiveRecordBody !== null ? exports.IncentiveRecordBody.fromPartial(object.incentiveRecordBody) : undefined;
        message.minUptime = object.minUptime !== undefined && object.minUptime !== null ? duration_1.Duration.fromPartial(object.minUptime) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            incentiveId: BigInt(object.incentive_id),
            poolId: BigInt(object.pool_id),
            incentiveRecordBody: object?.incentive_record_body ? exports.IncentiveRecordBody.fromAmino(object.incentive_record_body) : undefined,
            minUptime: object?.min_uptime ? duration_1.Duration.fromAmino(object.min_uptime) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.incentive_id = message.incentiveId ? message.incentiveId.toString() : undefined;
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.incentive_record_body = message.incentiveRecordBody ? exports.IncentiveRecordBody.toAmino(message.incentiveRecordBody) : undefined;
        obj.min_uptime = message.minUptime ? duration_1.Duration.toAmino(message.minUptime) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.IncentiveRecord.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-record",
            value: exports.IncentiveRecord.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.IncentiveRecord.decode(message.value);
    },
    toProto(message) {
        return exports.IncentiveRecord.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecord",
            value: exports.IncentiveRecord.encode(message).finish()
        };
    }
};
function createBaseIncentiveRecordBody() {
    return {
        remainingCoin: coin_1.DecCoin.fromPartial({}),
        emissionRate: "",
        startTime: undefined
    };
}
exports.IncentiveRecordBody = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.remainingCoin !== undefined) {
            coin_1.DecCoin.encode(message.remainingCoin, writer.uint32(10).fork()).ldelim();
        }
        if (message.emissionRate !== "") {
            writer.uint32(18).string(math_1.Decimal.fromUserInput(message.emissionRate, 18).atomics);
        }
        if (message.startTime !== undefined) {
            timestamp_1.Timestamp.encode((0, helpers_1.toTimestamp)(message.startTime), writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecordBody();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.remainingCoin = coin_1.DecCoin.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.emissionRate = math_1.Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 3:
                    message.startTime = (0, helpers_1.fromTimestamp)(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecordBody();
        message.remainingCoin = object.remainingCoin !== undefined && object.remainingCoin !== null ? coin_1.DecCoin.fromPartial(object.remainingCoin) : undefined;
        message.emissionRate = object.emissionRate ?? "";
        message.startTime = object.startTime ?? undefined;
        return message;
    },
    fromAmino(object) {
        return {
            remainingCoin: object?.remaining_coin ? coin_1.DecCoin.fromAmino(object.remaining_coin) : undefined,
            emissionRate: object.emission_rate,
            startTime: object.start_time
        };
    },
    toAmino(message) {
        const obj = {};
        obj.remaining_coin = message.remainingCoin ? coin_1.DecCoin.toAmino(message.remainingCoin) : undefined;
        obj.emission_rate = message.emissionRate;
        obj.start_time = message.startTime;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.IncentiveRecordBody.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-record-body",
            value: exports.IncentiveRecordBody.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.IncentiveRecordBody.decode(message.value);
    },
    toProto(message) {
        return exports.IncentiveRecordBody.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody",
            value: exports.IncentiveRecordBody.encode(message).finish()
        };
    }
};
//# sourceMappingURL=incentive_record.js.map
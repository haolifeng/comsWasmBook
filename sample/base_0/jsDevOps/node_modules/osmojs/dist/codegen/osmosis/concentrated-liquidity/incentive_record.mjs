import { Duration } from "../../google/protobuf/duration";
import { DecCoin } from "../../cosmos/base/v1beta1/coin";
import { Timestamp } from "../../google/protobuf/timestamp";
import { BinaryReader, BinaryWriter } from "../../binary";
import { Decimal } from "@cosmjs/math";
import { toTimestamp, fromTimestamp } from "../../helpers";
function createBaseIncentiveRecord() {
    return {
        incentiveId: BigInt(0),
        poolId: BigInt(0),
        incentiveRecordBody: IncentiveRecordBody.fromPartial({}),
        minUptime: undefined
    };
}
export const IncentiveRecord = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecord",
    encode(message, writer = BinaryWriter.create()) {
        if (message.incentiveId !== BigInt(0)) {
            writer.uint32(8).uint64(message.incentiveId);
        }
        if (message.poolId !== BigInt(0)) {
            writer.uint32(16).uint64(message.poolId);
        }
        if (message.incentiveRecordBody !== undefined) {
            IncentiveRecordBody.encode(message.incentiveRecordBody, writer.uint32(34).fork()).ldelim();
        }
        if (message.minUptime !== undefined) {
            Duration.encode(message.minUptime, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.incentiveId = reader.uint64();
                    break;
                case 2:
                    message.poolId = reader.uint64();
                    break;
                case 4:
                    message.incentiveRecordBody = IncentiveRecordBody.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.minUptime = Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecord();
        message.incentiveId = object.incentiveId !== undefined && object.incentiveId !== null ? BigInt(object.incentiveId.toString()) : BigInt(0);
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.incentiveRecordBody = object.incentiveRecordBody !== undefined && object.incentiveRecordBody !== null ? IncentiveRecordBody.fromPartial(object.incentiveRecordBody) : undefined;
        message.minUptime = object.minUptime !== undefined && object.minUptime !== null ? Duration.fromPartial(object.minUptime) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            incentiveId: BigInt(object.incentive_id),
            poolId: BigInt(object.pool_id),
            incentiveRecordBody: object?.incentive_record_body ? IncentiveRecordBody.fromAmino(object.incentive_record_body) : undefined,
            minUptime: object?.min_uptime ? Duration.fromAmino(object.min_uptime) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.incentive_id = message.incentiveId ? message.incentiveId.toString() : undefined;
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.incentive_record_body = message.incentiveRecordBody ? IncentiveRecordBody.toAmino(message.incentiveRecordBody) : undefined;
        obj.min_uptime = message.minUptime ? Duration.toAmino(message.minUptime) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return IncentiveRecord.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-record",
            value: IncentiveRecord.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return IncentiveRecord.decode(message.value);
    },
    toProto(message) {
        return IncentiveRecord.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecord",
            value: IncentiveRecord.encode(message).finish()
        };
    }
};
function createBaseIncentiveRecordBody() {
    return {
        remainingCoin: DecCoin.fromPartial({}),
        emissionRate: "",
        startTime: undefined
    };
}
export const IncentiveRecordBody = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody",
    encode(message, writer = BinaryWriter.create()) {
        if (message.remainingCoin !== undefined) {
            DecCoin.encode(message.remainingCoin, writer.uint32(10).fork()).ldelim();
        }
        if (message.emissionRate !== "") {
            writer.uint32(18).string(Decimal.fromUserInput(message.emissionRate, 18).atomics);
        }
        if (message.startTime !== undefined) {
            Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecordBody();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.remainingCoin = DecCoin.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.emissionRate = Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 3:
                    message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecordBody();
        message.remainingCoin = object.remainingCoin !== undefined && object.remainingCoin !== null ? DecCoin.fromPartial(object.remainingCoin) : undefined;
        message.emissionRate = object.emissionRate ?? "";
        message.startTime = object.startTime ?? undefined;
        return message;
    },
    fromAmino(object) {
        return {
            remainingCoin: object?.remaining_coin ? DecCoin.fromAmino(object.remaining_coin) : undefined,
            emissionRate: object.emission_rate,
            startTime: object.start_time
        };
    },
    toAmino(message) {
        const obj = {};
        obj.remaining_coin = message.remainingCoin ? DecCoin.toAmino(message.remainingCoin) : undefined;
        obj.emission_rate = message.emissionRate;
        obj.start_time = message.startTime;
        return obj;
    },
    fromAminoMsg(object) {
        return IncentiveRecordBody.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-record-body",
            value: IncentiveRecordBody.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return IncentiveRecordBody.decode(message.value);
    },
    toProto(message) {
        return IncentiveRecordBody.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody",
            value: IncentiveRecordBody.encode(message).finish()
        };
    }
};
//# sourceMappingURL=incentive_record.js.map
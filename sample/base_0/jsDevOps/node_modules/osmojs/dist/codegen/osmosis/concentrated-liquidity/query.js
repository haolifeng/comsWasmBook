"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolI_ToAmino = exports.PoolI_FromAmino = exports.PoolI_InterfaceDecoder = exports.GetTotalLiquidityResponse = exports.GetTotalLiquidityRequest = exports.UserUnbondingPositionsResponse = exports.UserUnbondingPositionsRequest = exports.CFMMPoolIdLinkFromConcentratedPoolIdResponse = exports.CFMMPoolIdLinkFromConcentratedPoolIdRequest = exports.IncentiveRecordsResponse = exports.IncentiveRecordsRequest = exports.TickAccumulatorTrackersResponse = exports.TickAccumulatorTrackersRequest = exports.PoolAccumulatorRewardsResponse = exports.PoolAccumulatorRewardsRequest = exports.ClaimableIncentivesResponse = exports.ClaimableIncentivesRequest = exports.ClaimableSpreadRewardsResponse = exports.ClaimableSpreadRewardsRequest = exports.LiquidityPerTickRangeResponse = exports.LiquidityPerTickRangeRequest = exports.LiquidityNetInDirectionResponse = exports.LiquidityNetInDirectionRequest = exports.LiquidityDepthWithRange = exports.TickLiquidityNet = exports.ParamsResponse = exports.ParamsRequest = exports.PoolsResponse = exports.PoolsRequest = exports.PositionByIdResponse = exports.PositionByIdRequest = exports.UserPositionsResponse = exports.UserPositionsRequest = void 0;
const pagination_1 = require("../../cosmos/base/query/v1beta1/pagination");
const position_1 = require("./position");
const any_1 = require("../../google/protobuf/any");
const params_1 = require("./params");
const coin_1 = require("../../cosmos/base/v1beta1/coin");
const tickInfo_1 = require("./tickInfo");
const incentive_record_1 = require("./incentive_record");
const pool_1 = require("./pool");
const pool_2 = require("../cosmwasmpool/v1beta1/model/pool");
const balancerPool_1 = require("../gamm/pool-models/balancer/balancerPool");
const stableswap_pool_1 = require("../gamm/pool-models/stableswap/stableswap_pool");
const binary_1 = require("../../binary");
const math_1 = require("@cosmjs/math");
function createBaseUserPositionsRequest() {
    return {
        address: "",
        poolId: BigInt(0),
        pagination: pagination_1.PageRequest.fromPartial({})
    };
}
exports.UserPositionsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.poolId !== BigInt(0)) {
            writer.uint32(16).uint64(message.poolId);
        }
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserPositionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.poolId = reader.uint64();
                    break;
                case 3:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserPositionsRequest();
        message.address = object.address ?? "";
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            address: object.address,
            poolId: BigInt(object.pool_id),
            pagination: object?.pagination ? pagination_1.PageRequest.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.address = message.address;
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.pagination = message.pagination ? pagination_1.PageRequest.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.UserPositionsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-positions-request",
            value: exports.UserPositionsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.UserPositionsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.UserPositionsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsRequest",
            value: exports.UserPositionsRequest.encode(message).finish()
        };
    }
};
function createBaseUserPositionsResponse() {
    return {
        positions: [],
        pagination: pagination_1.PageResponse.fromPartial({})
    };
}
exports.UserPositionsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.positions) {
            position_1.FullPositionBreakdown.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserPositionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positions.push(position_1.FullPositionBreakdown.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserPositionsResponse();
        message.positions = object.positions?.map(e => position_1.FullPositionBreakdown.fromPartial(e)) || [];
        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            positions: Array.isArray(object?.positions) ? object.positions.map((e) => position_1.FullPositionBreakdown.fromAmino(e)) : [],
            pagination: object?.pagination ? pagination_1.PageResponse.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.positions) {
            obj.positions = message.positions.map(e => e ? position_1.FullPositionBreakdown.toAmino(e) : undefined);
        }
        else {
            obj.positions = [];
        }
        obj.pagination = message.pagination ? pagination_1.PageResponse.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.UserPositionsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-positions-response",
            value: exports.UserPositionsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.UserPositionsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.UserPositionsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsResponse",
            value: exports.UserPositionsResponse.encode(message).finish()
        };
    }
};
function createBasePositionByIdRequest() {
    return {
        positionId: BigInt(0)
    };
}
exports.PositionByIdRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionByIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePositionByIdRequest();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PositionByIdRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/position-by-id-request",
            value: exports.PositionByIdRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PositionByIdRequest.decode(message.value);
    },
    toProto(message) {
        return exports.PositionByIdRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdRequest",
            value: exports.PositionByIdRequest.encode(message).finish()
        };
    }
};
function createBasePositionByIdResponse() {
    return {
        position: position_1.FullPositionBreakdown.fromPartial({})
    };
}
exports.PositionByIdResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.position !== undefined) {
            position_1.FullPositionBreakdown.encode(message.position, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionByIdResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.position = position_1.FullPositionBreakdown.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePositionByIdResponse();
        message.position = object.position !== undefined && object.position !== null ? position_1.FullPositionBreakdown.fromPartial(object.position) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            position: object?.position ? position_1.FullPositionBreakdown.fromAmino(object.position) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position = message.position ? position_1.FullPositionBreakdown.toAmino(message.position) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PositionByIdResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/position-by-id-response",
            value: exports.PositionByIdResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PositionByIdResponse.decode(message.value);
    },
    toProto(message) {
        return exports.PositionByIdResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdResponse",
            value: exports.PositionByIdResponse.encode(message).finish()
        };
    }
};
function createBasePoolsRequest() {
    return {
        pagination: pagination_1.PageRequest.fromPartial({})
    };
}
exports.PoolsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolsRequest();
        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            pagination: object?.pagination ? pagination_1.PageRequest.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pagination = message.pagination ? pagination_1.PageRequest.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PoolsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pools-request",
            value: exports.PoolsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PoolsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.PoolsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsRequest",
            value: exports.PoolsRequest.encode(message).finish()
        };
    }
};
function createBasePoolsResponse() {
    return {
        pools: [],
        pagination: pagination_1.PageResponse.fromPartial({})
    };
}
exports.PoolsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pools) {
            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pools.push((0, exports.PoolI_InterfaceDecoder)(reader));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolsResponse();
        message.pools = object.pools?.map(e => any_1.Any.fromPartial(e)) || [];
        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            pools: Array.isArray(object?.pools) ? object.pools.map((e) => (0, exports.PoolI_FromAmino)(e)) : [],
            pagination: object?.pagination ? pagination_1.PageResponse.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.pools) {
            obj.pools = message.pools.map(e => e ? (0, exports.PoolI_ToAmino)(e) : undefined);
        }
        else {
            obj.pools = [];
        }
        obj.pagination = message.pagination ? pagination_1.PageResponse.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PoolsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pools-response",
            value: exports.PoolsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PoolsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.PoolsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsResponse",
            value: exports.PoolsResponse.encode(message).finish()
        };
    }
};
function createBaseParamsRequest() {
    return {};
}
exports.ParamsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsRequest",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParamsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseParamsRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ParamsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/params-request",
            value: exports.ParamsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ParamsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.ParamsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsRequest",
            value: exports.ParamsRequest.encode(message).finish()
        };
    }
};
function createBaseParamsResponse() {
    return {
        params: params_1.Params.fromPartial({})
    };
}
exports.ParamsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) {
            params_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = params_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseParamsResponse();
        message.params = object.params !== undefined && object.params !== null ? params_1.Params.fromPartial(object.params) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            params: object?.params ? params_1.Params.fromAmino(object.params) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.params = message.params ? params_1.Params.toAmino(message.params) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ParamsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/params-response",
            value: exports.ParamsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ParamsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.ParamsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsResponse",
            value: exports.ParamsResponse.encode(message).finish()
        };
    }
};
function createBaseTickLiquidityNet() {
    return {
        liquidityNet: "",
        tickIndex: BigInt(0)
    };
}
exports.TickLiquidityNet = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickLiquidityNet",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.liquidityNet !== "") {
            writer.uint32(10).string(math_1.Decimal.fromUserInput(message.liquidityNet, 18).atomics);
        }
        if (message.tickIndex !== BigInt(0)) {
            writer.uint32(16).int64(message.tickIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTickLiquidityNet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidityNet = math_1.Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 2:
                    message.tickIndex = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTickLiquidityNet();
        message.liquidityNet = object.liquidityNet ?? "";
        message.tickIndex = object.tickIndex !== undefined && object.tickIndex !== null ? BigInt(object.tickIndex.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            liquidityNet: object.liquidity_net,
            tickIndex: BigInt(object.tick_index)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.liquidity_net = message.liquidityNet;
        obj.tick_index = message.tickIndex ? message.tickIndex.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TickLiquidityNet.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/tick-liquidity-net",
            value: exports.TickLiquidityNet.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.TickLiquidityNet.decode(message.value);
    },
    toProto(message) {
        return exports.TickLiquidityNet.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickLiquidityNet",
            value: exports.TickLiquidityNet.encode(message).finish()
        };
    }
};
function createBaseLiquidityDepthWithRange() {
    return {
        liquidityAmount: "",
        lowerTick: BigInt(0),
        upperTick: BigInt(0)
    };
}
exports.LiquidityDepthWithRange = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityDepthWithRange",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.liquidityAmount !== "") {
            writer.uint32(10).string(math_1.Decimal.fromUserInput(message.liquidityAmount, 18).atomics);
        }
        if (message.lowerTick !== BigInt(0)) {
            writer.uint32(16).int64(message.lowerTick);
        }
        if (message.upperTick !== BigInt(0)) {
            writer.uint32(24).int64(message.upperTick);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityDepthWithRange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidityAmount = math_1.Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 2:
                    message.lowerTick = reader.int64();
                    break;
                case 3:
                    message.upperTick = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityDepthWithRange();
        message.liquidityAmount = object.liquidityAmount ?? "";
        message.lowerTick = object.lowerTick !== undefined && object.lowerTick !== null ? BigInt(object.lowerTick.toString()) : BigInt(0);
        message.upperTick = object.upperTick !== undefined && object.upperTick !== null ? BigInt(object.upperTick.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            liquidityAmount: object.liquidity_amount,
            lowerTick: BigInt(object.lower_tick),
            upperTick: BigInt(object.upper_tick)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.liquidity_amount = message.liquidityAmount;
        obj.lower_tick = message.lowerTick ? message.lowerTick.toString() : undefined;
        obj.upper_tick = message.upperTick ? message.upperTick.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.LiquidityDepthWithRange.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-depth-with-range",
            value: exports.LiquidityDepthWithRange.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.LiquidityDepthWithRange.decode(message.value);
    },
    toProto(message) {
        return exports.LiquidityDepthWithRange.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityDepthWithRange",
            value: exports.LiquidityDepthWithRange.encode(message).finish()
        };
    }
};
function createBaseLiquidityNetInDirectionRequest() {
    return {
        poolId: BigInt(0),
        tokenIn: "",
        startTick: BigInt(0),
        useCurTick: false,
        boundTick: BigInt(0),
        useNoBound: false
    };
}
exports.LiquidityNetInDirectionRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tokenIn !== "") {
            writer.uint32(18).string(message.tokenIn);
        }
        if (message.startTick !== BigInt(0)) {
            writer.uint32(24).int64(message.startTick);
        }
        if (message.useCurTick === true) {
            writer.uint32(32).bool(message.useCurTick);
        }
        if (message.boundTick !== BigInt(0)) {
            writer.uint32(40).int64(message.boundTick);
        }
        if (message.useNoBound === true) {
            writer.uint32(48).bool(message.useNoBound);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityNetInDirectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tokenIn = reader.string();
                    break;
                case 3:
                    message.startTick = reader.int64();
                    break;
                case 4:
                    message.useCurTick = reader.bool();
                    break;
                case 5:
                    message.boundTick = reader.int64();
                    break;
                case 6:
                    message.useNoBound = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityNetInDirectionRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tokenIn = object.tokenIn ?? "";
        message.startTick = object.startTick !== undefined && object.startTick !== null ? BigInt(object.startTick.toString()) : BigInt(0);
        message.useCurTick = object.useCurTick ?? false;
        message.boundTick = object.boundTick !== undefined && object.boundTick !== null ? BigInt(object.boundTick.toString()) : BigInt(0);
        message.useNoBound = object.useNoBound ?? false;
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tokenIn: object.token_in,
            startTick: BigInt(object.start_tick),
            useCurTick: object.use_cur_tick,
            boundTick: BigInt(object.bound_tick),
            useNoBound: object.use_no_bound
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.token_in = message.tokenIn;
        obj.start_tick = message.startTick ? message.startTick.toString() : undefined;
        obj.use_cur_tick = message.useCurTick;
        obj.bound_tick = message.boundTick ? message.boundTick.toString() : undefined;
        obj.use_no_bound = message.useNoBound;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.LiquidityNetInDirectionRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-net-in-direction-request",
            value: exports.LiquidityNetInDirectionRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.LiquidityNetInDirectionRequest.decode(message.value);
    },
    toProto(message) {
        return exports.LiquidityNetInDirectionRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionRequest",
            value: exports.LiquidityNetInDirectionRequest.encode(message).finish()
        };
    }
};
function createBaseLiquidityNetInDirectionResponse() {
    return {
        liquidityDepths: [],
        currentTick: BigInt(0),
        currentLiquidity: ""
    };
}
exports.LiquidityNetInDirectionResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.liquidityDepths) {
            exports.TickLiquidityNet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.currentTick !== BigInt(0)) {
            writer.uint32(16).int64(message.currentTick);
        }
        if (message.currentLiquidity !== "") {
            writer.uint32(26).string(math_1.Decimal.fromUserInput(message.currentLiquidity, 18).atomics);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityNetInDirectionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidityDepths.push(exports.TickLiquidityNet.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.currentTick = reader.int64();
                    break;
                case 3:
                    message.currentLiquidity = math_1.Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityNetInDirectionResponse();
        message.liquidityDepths = object.liquidityDepths?.map(e => exports.TickLiquidityNet.fromPartial(e)) || [];
        message.currentTick = object.currentTick !== undefined && object.currentTick !== null ? BigInt(object.currentTick.toString()) : BigInt(0);
        message.currentLiquidity = object.currentLiquidity ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            liquidityDepths: Array.isArray(object?.liquidity_depths) ? object.liquidity_depths.map((e) => exports.TickLiquidityNet.fromAmino(e)) : [],
            currentTick: BigInt(object.current_tick),
            currentLiquidity: object.current_liquidity
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.liquidityDepths) {
            obj.liquidity_depths = message.liquidityDepths.map(e => e ? exports.TickLiquidityNet.toAmino(e) : undefined);
        }
        else {
            obj.liquidity_depths = [];
        }
        obj.current_tick = message.currentTick ? message.currentTick.toString() : undefined;
        obj.current_liquidity = message.currentLiquidity;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.LiquidityNetInDirectionResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-net-in-direction-response",
            value: exports.LiquidityNetInDirectionResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.LiquidityNetInDirectionResponse.decode(message.value);
    },
    toProto(message) {
        return exports.LiquidityNetInDirectionResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionResponse",
            value: exports.LiquidityNetInDirectionResponse.encode(message).finish()
        };
    }
};
function createBaseLiquidityPerTickRangeRequest() {
    return {
        poolId: BigInt(0)
    };
}
exports.LiquidityPerTickRangeRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityPerTickRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityPerTickRangeRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.LiquidityPerTickRangeRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-per-tick-range-request",
            value: exports.LiquidityPerTickRangeRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.LiquidityPerTickRangeRequest.decode(message.value);
    },
    toProto(message) {
        return exports.LiquidityPerTickRangeRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeRequest",
            value: exports.LiquidityPerTickRangeRequest.encode(message).finish()
        };
    }
};
function createBaseLiquidityPerTickRangeResponse() {
    return {
        liquidity: []
    };
}
exports.LiquidityPerTickRangeResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.liquidity) {
            exports.LiquidityDepthWithRange.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityPerTickRangeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidity.push(exports.LiquidityDepthWithRange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityPerTickRangeResponse();
        message.liquidity = object.liquidity?.map(e => exports.LiquidityDepthWithRange.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            liquidity: Array.isArray(object?.liquidity) ? object.liquidity.map((e) => exports.LiquidityDepthWithRange.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.liquidity) {
            obj.liquidity = message.liquidity.map(e => e ? exports.LiquidityDepthWithRange.toAmino(e) : undefined);
        }
        else {
            obj.liquidity = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.LiquidityPerTickRangeResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-per-tick-range-response",
            value: exports.LiquidityPerTickRangeResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.LiquidityPerTickRangeResponse.decode(message.value);
    },
    toProto(message) {
        return exports.LiquidityPerTickRangeResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeResponse",
            value: exports.LiquidityPerTickRangeResponse.encode(message).finish()
        };
    }
};
function createBaseClaimableSpreadRewardsRequest() {
    return {
        positionId: BigInt(0)
    };
}
exports.ClaimableSpreadRewardsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableSpreadRewardsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableSpreadRewardsRequest();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ClaimableSpreadRewardsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-spread-rewards-request",
            value: exports.ClaimableSpreadRewardsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ClaimableSpreadRewardsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.ClaimableSpreadRewardsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsRequest",
            value: exports.ClaimableSpreadRewardsRequest.encode(message).finish()
        };
    }
};
function createBaseClaimableSpreadRewardsResponse() {
    return {
        claimableSpreadRewards: []
    };
}
exports.ClaimableSpreadRewardsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.claimableSpreadRewards) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableSpreadRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.claimableSpreadRewards.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableSpreadRewardsResponse();
        message.claimableSpreadRewards = object.claimableSpreadRewards?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            claimableSpreadRewards: Array.isArray(object?.claimable_spread_rewards) ? object.claimable_spread_rewards.map((e) => coin_1.Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.claimableSpreadRewards) {
            obj.claimable_spread_rewards = message.claimableSpreadRewards.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.claimable_spread_rewards = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ClaimableSpreadRewardsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-spread-rewards-response",
            value: exports.ClaimableSpreadRewardsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ClaimableSpreadRewardsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.ClaimableSpreadRewardsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsResponse",
            value: exports.ClaimableSpreadRewardsResponse.encode(message).finish()
        };
    }
};
function createBaseClaimableIncentivesRequest() {
    return {
        positionId: BigInt(0)
    };
}
exports.ClaimableIncentivesRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableIncentivesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableIncentivesRequest();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ClaimableIncentivesRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-incentives-request",
            value: exports.ClaimableIncentivesRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ClaimableIncentivesRequest.decode(message.value);
    },
    toProto(message) {
        return exports.ClaimableIncentivesRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesRequest",
            value: exports.ClaimableIncentivesRequest.encode(message).finish()
        };
    }
};
function createBaseClaimableIncentivesResponse() {
    return {
        claimableIncentives: [],
        forfeitedIncentives: []
    };
}
exports.ClaimableIncentivesResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.claimableIncentives) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.forfeitedIncentives) {
            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableIncentivesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.claimableIncentives.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.forfeitedIncentives.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableIncentivesResponse();
        message.claimableIncentives = object.claimableIncentives?.map(e => coin_1.Coin.fromPartial(e)) || [];
        message.forfeitedIncentives = object.forfeitedIncentives?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            claimableIncentives: Array.isArray(object?.claimable_incentives) ? object.claimable_incentives.map((e) => coin_1.Coin.fromAmino(e)) : [],
            forfeitedIncentives: Array.isArray(object?.forfeited_incentives) ? object.forfeited_incentives.map((e) => coin_1.Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.claimableIncentives) {
            obj.claimable_incentives = message.claimableIncentives.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.claimable_incentives = [];
        }
        if (message.forfeitedIncentives) {
            obj.forfeited_incentives = message.forfeitedIncentives.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.forfeited_incentives = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ClaimableIncentivesResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-incentives-response",
            value: exports.ClaimableIncentivesResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ClaimableIncentivesResponse.decode(message.value);
    },
    toProto(message) {
        return exports.ClaimableIncentivesResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesResponse",
            value: exports.ClaimableIncentivesResponse.encode(message).finish()
        };
    }
};
function createBasePoolAccumulatorRewardsRequest() {
    return {
        poolId: BigInt(0)
    };
}
exports.PoolAccumulatorRewardsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolAccumulatorRewardsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolAccumulatorRewardsRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PoolAccumulatorRewardsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pool-accumulator-rewards-request",
            value: exports.PoolAccumulatorRewardsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PoolAccumulatorRewardsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.PoolAccumulatorRewardsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsRequest",
            value: exports.PoolAccumulatorRewardsRequest.encode(message).finish()
        };
    }
};
function createBasePoolAccumulatorRewardsResponse() {
    return {
        spreadRewardGrowthGlobal: [],
        uptimeGrowthGlobal: []
    };
}
exports.PoolAccumulatorRewardsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.spreadRewardGrowthGlobal) {
            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.uptimeGrowthGlobal) {
            tickInfo_1.UptimeTracker.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolAccumulatorRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spreadRewardGrowthGlobal.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.uptimeGrowthGlobal.push(tickInfo_1.UptimeTracker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolAccumulatorRewardsResponse();
        message.spreadRewardGrowthGlobal = object.spreadRewardGrowthGlobal?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
        message.uptimeGrowthGlobal = object.uptimeGrowthGlobal?.map(e => tickInfo_1.UptimeTracker.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            spreadRewardGrowthGlobal: Array.isArray(object?.spread_reward_growth_global) ? object.spread_reward_growth_global.map((e) => coin_1.DecCoin.fromAmino(e)) : [],
            uptimeGrowthGlobal: Array.isArray(object?.uptime_growth_global) ? object.uptime_growth_global.map((e) => tickInfo_1.UptimeTracker.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.spreadRewardGrowthGlobal) {
            obj.spread_reward_growth_global = message.spreadRewardGrowthGlobal.map(e => e ? coin_1.DecCoin.toAmino(e) : undefined);
        }
        else {
            obj.spread_reward_growth_global = [];
        }
        if (message.uptimeGrowthGlobal) {
            obj.uptime_growth_global = message.uptimeGrowthGlobal.map(e => e ? tickInfo_1.UptimeTracker.toAmino(e) : undefined);
        }
        else {
            obj.uptime_growth_global = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PoolAccumulatorRewardsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pool-accumulator-rewards-response",
            value: exports.PoolAccumulatorRewardsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PoolAccumulatorRewardsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.PoolAccumulatorRewardsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsResponse",
            value: exports.PoolAccumulatorRewardsResponse.encode(message).finish()
        };
    }
};
function createBaseTickAccumulatorTrackersRequest() {
    return {
        poolId: BigInt(0),
        tickIndex: BigInt(0)
    };
}
exports.TickAccumulatorTrackersRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tickIndex !== BigInt(0)) {
            writer.uint32(16).int64(message.tickIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTickAccumulatorTrackersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tickIndex = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTickAccumulatorTrackersRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tickIndex = object.tickIndex !== undefined && object.tickIndex !== null ? BigInt(object.tickIndex.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tickIndex: BigInt(object.tick_index)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.tick_index = message.tickIndex ? message.tickIndex.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TickAccumulatorTrackersRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/tick-accumulator-trackers-request",
            value: exports.TickAccumulatorTrackersRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.TickAccumulatorTrackersRequest.decode(message.value);
    },
    toProto(message) {
        return exports.TickAccumulatorTrackersRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersRequest",
            value: exports.TickAccumulatorTrackersRequest.encode(message).finish()
        };
    }
};
function createBaseTickAccumulatorTrackersResponse() {
    return {
        spreadRewardGrowthOppositeDirectionOfLastTraversal: [],
        uptimeTrackers: []
    };
}
exports.TickAccumulatorTrackersResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.spreadRewardGrowthOppositeDirectionOfLastTraversal) {
            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.uptimeTrackers) {
            tickInfo_1.UptimeTracker.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTickAccumulatorTrackersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spreadRewardGrowthOppositeDirectionOfLastTraversal.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.uptimeTrackers.push(tickInfo_1.UptimeTracker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTickAccumulatorTrackersResponse();
        message.spreadRewardGrowthOppositeDirectionOfLastTraversal = object.spreadRewardGrowthOppositeDirectionOfLastTraversal?.map(e => coin_1.DecCoin.fromPartial(e)) || [];
        message.uptimeTrackers = object.uptimeTrackers?.map(e => tickInfo_1.UptimeTracker.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            spreadRewardGrowthOppositeDirectionOfLastTraversal: Array.isArray(object?.spread_reward_growth_opposite_direction_of_last_traversal) ? object.spread_reward_growth_opposite_direction_of_last_traversal.map((e) => coin_1.DecCoin.fromAmino(e)) : [],
            uptimeTrackers: Array.isArray(object?.uptime_trackers) ? object.uptime_trackers.map((e) => tickInfo_1.UptimeTracker.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.spreadRewardGrowthOppositeDirectionOfLastTraversal) {
            obj.spread_reward_growth_opposite_direction_of_last_traversal = message.spreadRewardGrowthOppositeDirectionOfLastTraversal.map(e => e ? coin_1.DecCoin.toAmino(e) : undefined);
        }
        else {
            obj.spread_reward_growth_opposite_direction_of_last_traversal = [];
        }
        if (message.uptimeTrackers) {
            obj.uptime_trackers = message.uptimeTrackers.map(e => e ? tickInfo_1.UptimeTracker.toAmino(e) : undefined);
        }
        else {
            obj.uptime_trackers = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TickAccumulatorTrackersResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/tick-accumulator-trackers-response",
            value: exports.TickAccumulatorTrackersResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.TickAccumulatorTrackersResponse.decode(message.value);
    },
    toProto(message) {
        return exports.TickAccumulatorTrackersResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersResponse",
            value: exports.TickAccumulatorTrackersResponse.encode(message).finish()
        };
    }
};
function createBaseIncentiveRecordsRequest() {
    return {
        poolId: BigInt(0),
        pagination: pagination_1.PageRequest.fromPartial({})
    };
}
exports.IncentiveRecordsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecordsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecordsRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            pagination: object?.pagination ? pagination_1.PageRequest.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.pagination = message.pagination ? pagination_1.PageRequest.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.IncentiveRecordsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-records-request",
            value: exports.IncentiveRecordsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.IncentiveRecordsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.IncentiveRecordsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsRequest",
            value: exports.IncentiveRecordsRequest.encode(message).finish()
        };
    }
};
function createBaseIncentiveRecordsResponse() {
    return {
        incentiveRecords: [],
        pagination: pagination_1.PageResponse.fromPartial({})
    };
}
exports.IncentiveRecordsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.incentiveRecords) {
            incentive_record_1.IncentiveRecord.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecordsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.incentiveRecords.push(incentive_record_1.IncentiveRecord.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecordsResponse();
        message.incentiveRecords = object.incentiveRecords?.map(e => incentive_record_1.IncentiveRecord.fromPartial(e)) || [];
        message.pagination = object.pagination !== undefined && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            incentiveRecords: Array.isArray(object?.incentive_records) ? object.incentive_records.map((e) => incentive_record_1.IncentiveRecord.fromAmino(e)) : [],
            pagination: object?.pagination ? pagination_1.PageResponse.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.incentiveRecords) {
            obj.incentive_records = message.incentiveRecords.map(e => e ? incentive_record_1.IncentiveRecord.toAmino(e) : undefined);
        }
        else {
            obj.incentive_records = [];
        }
        obj.pagination = message.pagination ? pagination_1.PageResponse.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.IncentiveRecordsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-records-response",
            value: exports.IncentiveRecordsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.IncentiveRecordsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.IncentiveRecordsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsResponse",
            value: exports.IncentiveRecordsResponse.encode(message).finish()
        };
    }
};
function createBaseCFMMPoolIdLinkFromConcentratedPoolIdRequest() {
    return {
        concentratedPoolId: BigInt(0)
    };
}
exports.CFMMPoolIdLinkFromConcentratedPoolIdRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.concentratedPoolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.concentratedPoolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.concentratedPoolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdRequest();
        message.concentratedPoolId = object.concentratedPoolId !== undefined && object.concentratedPoolId !== null ? BigInt(object.concentratedPoolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            concentratedPoolId: BigInt(object.concentrated_pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.concentrated_pool_id = message.concentratedPoolId ? message.concentratedPoolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.CFMMPoolIdLinkFromConcentratedPoolIdRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/cfmmpool-id-link-from-concentrated-pool-id-request",
            value: exports.CFMMPoolIdLinkFromConcentratedPoolIdRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.CFMMPoolIdLinkFromConcentratedPoolIdRequest.decode(message.value);
    },
    toProto(message) {
        return exports.CFMMPoolIdLinkFromConcentratedPoolIdRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdRequest",
            value: exports.CFMMPoolIdLinkFromConcentratedPoolIdRequest.encode(message).finish()
        };
    }
};
function createBaseCFMMPoolIdLinkFromConcentratedPoolIdResponse() {
    return {
        cfmmPoolId: BigInt(0)
    };
}
exports.CFMMPoolIdLinkFromConcentratedPoolIdResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.cfmmPoolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.cfmmPoolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cfmmPoolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdResponse();
        message.cfmmPoolId = object.cfmmPoolId !== undefined && object.cfmmPoolId !== null ? BigInt(object.cfmmPoolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            cfmmPoolId: BigInt(object.cfmm_pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.cfmm_pool_id = message.cfmmPoolId ? message.cfmmPoolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.CFMMPoolIdLinkFromConcentratedPoolIdResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/cfmmpool-id-link-from-concentrated-pool-id-response",
            value: exports.CFMMPoolIdLinkFromConcentratedPoolIdResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.CFMMPoolIdLinkFromConcentratedPoolIdResponse.decode(message.value);
    },
    toProto(message) {
        return exports.CFMMPoolIdLinkFromConcentratedPoolIdResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdResponse",
            value: exports.CFMMPoolIdLinkFromConcentratedPoolIdResponse.encode(message).finish()
        };
    }
};
function createBaseUserUnbondingPositionsRequest() {
    return {
        address: ""
    };
}
exports.UserUnbondingPositionsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserUnbondingPositionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserUnbondingPositionsRequest();
        message.address = object.address ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            address: object.address
        };
    },
    toAmino(message) {
        const obj = {};
        obj.address = message.address;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.UserUnbondingPositionsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-unbonding-positions-request",
            value: exports.UserUnbondingPositionsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.UserUnbondingPositionsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.UserUnbondingPositionsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsRequest",
            value: exports.UserUnbondingPositionsRequest.encode(message).finish()
        };
    }
};
function createBaseUserUnbondingPositionsResponse() {
    return {
        positionsWithPeriodLock: []
    };
}
exports.UserUnbondingPositionsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.positionsWithPeriodLock) {
            position_1.PositionWithPeriodLock.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserUnbondingPositionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionsWithPeriodLock.push(position_1.PositionWithPeriodLock.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserUnbondingPositionsResponse();
        message.positionsWithPeriodLock = object.positionsWithPeriodLock?.map(e => position_1.PositionWithPeriodLock.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            positionsWithPeriodLock: Array.isArray(object?.positions_with_period_lock) ? object.positions_with_period_lock.map((e) => position_1.PositionWithPeriodLock.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.positionsWithPeriodLock) {
            obj.positions_with_period_lock = message.positionsWithPeriodLock.map(e => e ? position_1.PositionWithPeriodLock.toAmino(e) : undefined);
        }
        else {
            obj.positions_with_period_lock = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.UserUnbondingPositionsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-unbonding-positions-response",
            value: exports.UserUnbondingPositionsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.UserUnbondingPositionsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.UserUnbondingPositionsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsResponse",
            value: exports.UserUnbondingPositionsResponse.encode(message).finish()
        };
    }
};
function createBaseGetTotalLiquidityRequest() {
    return {};
}
exports.GetTotalLiquidityRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityRequest",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalLiquidityRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseGetTotalLiquidityRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.GetTotalLiquidityRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/get-total-liquidity-request",
            value: exports.GetTotalLiquidityRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.GetTotalLiquidityRequest.decode(message.value);
    },
    toProto(message) {
        return exports.GetTotalLiquidityRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityRequest",
            value: exports.GetTotalLiquidityRequest.encode(message).finish()
        };
    }
};
function createBaseGetTotalLiquidityResponse() {
    return {
        totalLiquidity: []
    };
}
exports.GetTotalLiquidityResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.totalLiquidity) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalLiquidityResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalLiquidity.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetTotalLiquidityResponse();
        message.totalLiquidity = object.totalLiquidity?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            totalLiquidity: Array.isArray(object?.total_liquidity) ? object.total_liquidity.map((e) => coin_1.Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.totalLiquidity) {
            obj.total_liquidity = message.totalLiquidity.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.total_liquidity = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.GetTotalLiquidityResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/get-total-liquidity-response",
            value: exports.GetTotalLiquidityResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.GetTotalLiquidityResponse.decode(message.value);
    },
    toProto(message) {
        return exports.GetTotalLiquidityResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityResponse",
            value: exports.GetTotalLiquidityResponse.encode(message).finish()
        };
    }
};
const PoolI_InterfaceDecoder = (input) => {
    const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
    const data = any_1.Any.decode(reader, reader.uint32());
    switch (data.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return pool_1.Pool.decode(data.value);
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return pool_2.CosmWasmPool.decode(data.value);
        case "/osmosis.gamm.v1beta1.Pool":
            return balancerPool_1.Pool.decode(data.value);
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return stableswap_pool_1.Pool.decode(data.value);
        default:
            return data;
    }
};
exports.PoolI_InterfaceDecoder = PoolI_InterfaceDecoder;
const PoolI_FromAmino = (content) => {
    switch (content.type) {
        case "osmosis/concentratedliquidity/pool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.concentratedliquidity.v1beta1.Pool",
                value: pool_1.Pool.encode(pool_1.Pool.fromPartial(pool_1.Pool.fromAmino(content.value))).finish()
            });
        case "osmosis/cosmwasmpool/cosm-wasm-pool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool",
                value: pool_2.CosmWasmPool.encode(pool_2.CosmWasmPool.fromPartial(pool_2.CosmWasmPool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/BalancerPool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.gamm.v1beta1.Pool",
                value: balancerPool_1.Pool.encode(balancerPool_1.Pool.fromPartial(balancerPool_1.Pool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/StableswapPool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool",
                value: stableswap_pool_1.Pool.encode(stableswap_pool_1.Pool.fromPartial(stableswap_pool_1.Pool.fromAmino(content.value))).finish()
            });
        default:
            return any_1.Any.fromAmino(content);
    }
};
exports.PoolI_FromAmino = PoolI_FromAmino;
const PoolI_ToAmino = (content) => {
    switch (content.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return {
                type: "osmosis/concentratedliquidity/pool",
                value: pool_1.Pool.toAmino(pool_1.Pool.decode(content.value))
            };
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return {
                type: "osmosis/cosmwasmpool/cosm-wasm-pool",
                value: pool_2.CosmWasmPool.toAmino(pool_2.CosmWasmPool.decode(content.value))
            };
        case "/osmosis.gamm.v1beta1.Pool":
            return {
                type: "osmosis/gamm/BalancerPool",
                value: balancerPool_1.Pool.toAmino(balancerPool_1.Pool.decode(content.value))
            };
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return {
                type: "osmosis/gamm/StableswapPool",
                value: stableswap_pool_1.Pool.toAmino(stableswap_pool_1.Pool.decode(content.value))
            };
        default:
            return any_1.Any.toAmino(content);
    }
};
exports.PoolI_ToAmino = PoolI_ToAmino;
//# sourceMappingURL=query.js.map
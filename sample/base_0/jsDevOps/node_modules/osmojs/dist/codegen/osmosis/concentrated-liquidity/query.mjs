import { PageRequest, PageResponse } from "../../cosmos/base/query/v1beta1/pagination";
import { FullPositionBreakdown, PositionWithPeriodLock } from "./position";
import { Any } from "../../google/protobuf/any";
import { Params } from "./params";
import { Coin, DecCoin } from "../../cosmos/base/v1beta1/coin";
import { UptimeTracker } from "./tickInfo";
import { IncentiveRecord } from "./incentive_record";
import { Pool as Pool1 } from "./pool";
import { CosmWasmPool } from "../cosmwasmpool/v1beta1/model/pool";
import { Pool as Pool2 } from "../gamm/pool-models/balancer/balancerPool";
import { Pool as Pool3 } from "../gamm/pool-models/stableswap/stableswap_pool";
import { BinaryReader, BinaryWriter } from "../../binary";
import { Decimal } from "@cosmjs/math";
function createBaseUserPositionsRequest() {
    return {
        address: "",
        poolId: BigInt(0),
        pagination: PageRequest.fromPartial({})
    };
}
export const UserPositionsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.poolId !== BigInt(0)) {
            writer.uint32(16).uint64(message.poolId);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserPositionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.poolId = reader.uint64();
                    break;
                case 3:
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserPositionsRequest();
        message.address = object.address ?? "";
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.pagination = object.pagination !== undefined && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            address: object.address,
            poolId: BigInt(object.pool_id),
            pagination: object?.pagination ? PageRequest.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.address = message.address;
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.pagination = message.pagination ? PageRequest.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return UserPositionsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-positions-request",
            value: UserPositionsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return UserPositionsRequest.decode(message.value);
    },
    toProto(message) {
        return UserPositionsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsRequest",
            value: UserPositionsRequest.encode(message).finish()
        };
    }
};
function createBaseUserPositionsResponse() {
    return {
        positions: [],
        pagination: PageResponse.fromPartial({})
    };
}
export const UserPositionsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.positions) {
            FullPositionBreakdown.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserPositionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positions.push(FullPositionBreakdown.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserPositionsResponse();
        message.positions = object.positions?.map(e => FullPositionBreakdown.fromPartial(e)) || [];
        message.pagination = object.pagination !== undefined && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            positions: Array.isArray(object?.positions) ? object.positions.map((e) => FullPositionBreakdown.fromAmino(e)) : [],
            pagination: object?.pagination ? PageResponse.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.positions) {
            obj.positions = message.positions.map(e => e ? FullPositionBreakdown.toAmino(e) : undefined);
        }
        else {
            obj.positions = [];
        }
        obj.pagination = message.pagination ? PageResponse.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return UserPositionsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-positions-response",
            value: UserPositionsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return UserPositionsResponse.decode(message.value);
    },
    toProto(message) {
        return UserPositionsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserPositionsResponse",
            value: UserPositionsResponse.encode(message).finish()
        };
    }
};
function createBasePositionByIdRequest() {
    return {
        positionId: BigInt(0)
    };
}
export const PositionByIdRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionByIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePositionByIdRequest();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return PositionByIdRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/position-by-id-request",
            value: PositionByIdRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PositionByIdRequest.decode(message.value);
    },
    toProto(message) {
        return PositionByIdRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdRequest",
            value: PositionByIdRequest.encode(message).finish()
        };
    }
};
function createBasePositionByIdResponse() {
    return {
        position: FullPositionBreakdown.fromPartial({})
    };
}
export const PositionByIdResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.position !== undefined) {
            FullPositionBreakdown.encode(message.position, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionByIdResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.position = FullPositionBreakdown.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePositionByIdResponse();
        message.position = object.position !== undefined && object.position !== null ? FullPositionBreakdown.fromPartial(object.position) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            position: object?.position ? FullPositionBreakdown.fromAmino(object.position) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position = message.position ? FullPositionBreakdown.toAmino(message.position) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return PositionByIdResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/position-by-id-response",
            value: PositionByIdResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PositionByIdResponse.decode(message.value);
    },
    toProto(message) {
        return PositionByIdResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PositionByIdResponse",
            value: PositionByIdResponse.encode(message).finish()
        };
    }
};
function createBasePoolsRequest() {
    return {
        pagination: PageRequest.fromPartial({})
    };
}
export const PoolsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolsRequest();
        message.pagination = object.pagination !== undefined && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            pagination: object?.pagination ? PageRequest.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pagination = message.pagination ? PageRequest.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return PoolsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pools-request",
            value: PoolsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PoolsRequest.decode(message.value);
    },
    toProto(message) {
        return PoolsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsRequest",
            value: PoolsRequest.encode(message).finish()
        };
    }
};
function createBasePoolsResponse() {
    return {
        pools: [],
        pagination: PageResponse.fromPartial({})
    };
}
export const PoolsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.pools) {
            Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pools.push(PoolI_InterfaceDecoder(reader));
                    break;
                case 2:
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolsResponse();
        message.pools = object.pools?.map(e => Any.fromPartial(e)) || [];
        message.pagination = object.pagination !== undefined && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            pools: Array.isArray(object?.pools) ? object.pools.map((e) => PoolI_FromAmino(e)) : [],
            pagination: object?.pagination ? PageResponse.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.pools) {
            obj.pools = message.pools.map(e => e ? PoolI_ToAmino(e) : undefined);
        }
        else {
            obj.pools = [];
        }
        obj.pagination = message.pagination ? PageResponse.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return PoolsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pools-response",
            value: PoolsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PoolsResponse.decode(message.value);
    },
    toProto(message) {
        return PoolsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolsResponse",
            value: PoolsResponse.encode(message).finish()
        };
    }
};
function createBaseParamsRequest() {
    return {};
}
export const ParamsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsRequest",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParamsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseParamsRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return ParamsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/params-request",
            value: ParamsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return ParamsRequest.decode(message.value);
    },
    toProto(message) {
        return ParamsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsRequest",
            value: ParamsRequest.encode(message).finish()
        };
    }
};
function createBaseParamsResponse() {
    return {
        params: Params.fromPartial({})
    };
}
export const ParamsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.params !== undefined) {
            Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseParamsResponse();
        message.params = object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            params: object?.params ? Params.fromAmino(object.params) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.params = message.params ? Params.toAmino(message.params) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return ParamsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/params-response",
            value: ParamsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return ParamsResponse.decode(message.value);
    },
    toProto(message) {
        return ParamsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ParamsResponse",
            value: ParamsResponse.encode(message).finish()
        };
    }
};
function createBaseTickLiquidityNet() {
    return {
        liquidityNet: "",
        tickIndex: BigInt(0)
    };
}
export const TickLiquidityNet = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickLiquidityNet",
    encode(message, writer = BinaryWriter.create()) {
        if (message.liquidityNet !== "") {
            writer.uint32(10).string(Decimal.fromUserInput(message.liquidityNet, 18).atomics);
        }
        if (message.tickIndex !== BigInt(0)) {
            writer.uint32(16).int64(message.tickIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTickLiquidityNet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidityNet = Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 2:
                    message.tickIndex = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTickLiquidityNet();
        message.liquidityNet = object.liquidityNet ?? "";
        message.tickIndex = object.tickIndex !== undefined && object.tickIndex !== null ? BigInt(object.tickIndex.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            liquidityNet: object.liquidity_net,
            tickIndex: BigInt(object.tick_index)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.liquidity_net = message.liquidityNet;
        obj.tick_index = message.tickIndex ? message.tickIndex.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return TickLiquidityNet.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/tick-liquidity-net",
            value: TickLiquidityNet.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return TickLiquidityNet.decode(message.value);
    },
    toProto(message) {
        return TickLiquidityNet.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickLiquidityNet",
            value: TickLiquidityNet.encode(message).finish()
        };
    }
};
function createBaseLiquidityDepthWithRange() {
    return {
        liquidityAmount: "",
        lowerTick: BigInt(0),
        upperTick: BigInt(0)
    };
}
export const LiquidityDepthWithRange = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityDepthWithRange",
    encode(message, writer = BinaryWriter.create()) {
        if (message.liquidityAmount !== "") {
            writer.uint32(10).string(Decimal.fromUserInput(message.liquidityAmount, 18).atomics);
        }
        if (message.lowerTick !== BigInt(0)) {
            writer.uint32(16).int64(message.lowerTick);
        }
        if (message.upperTick !== BigInt(0)) {
            writer.uint32(24).int64(message.upperTick);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityDepthWithRange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidityAmount = Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 2:
                    message.lowerTick = reader.int64();
                    break;
                case 3:
                    message.upperTick = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityDepthWithRange();
        message.liquidityAmount = object.liquidityAmount ?? "";
        message.lowerTick = object.lowerTick !== undefined && object.lowerTick !== null ? BigInt(object.lowerTick.toString()) : BigInt(0);
        message.upperTick = object.upperTick !== undefined && object.upperTick !== null ? BigInt(object.upperTick.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            liquidityAmount: object.liquidity_amount,
            lowerTick: BigInt(object.lower_tick),
            upperTick: BigInt(object.upper_tick)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.liquidity_amount = message.liquidityAmount;
        obj.lower_tick = message.lowerTick ? message.lowerTick.toString() : undefined;
        obj.upper_tick = message.upperTick ? message.upperTick.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return LiquidityDepthWithRange.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-depth-with-range",
            value: LiquidityDepthWithRange.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return LiquidityDepthWithRange.decode(message.value);
    },
    toProto(message) {
        return LiquidityDepthWithRange.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityDepthWithRange",
            value: LiquidityDepthWithRange.encode(message).finish()
        };
    }
};
function createBaseLiquidityNetInDirectionRequest() {
    return {
        poolId: BigInt(0),
        tokenIn: "",
        startTick: BigInt(0),
        useCurTick: false,
        boundTick: BigInt(0),
        useNoBound: false
    };
}
export const LiquidityNetInDirectionRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tokenIn !== "") {
            writer.uint32(18).string(message.tokenIn);
        }
        if (message.startTick !== BigInt(0)) {
            writer.uint32(24).int64(message.startTick);
        }
        if (message.useCurTick === true) {
            writer.uint32(32).bool(message.useCurTick);
        }
        if (message.boundTick !== BigInt(0)) {
            writer.uint32(40).int64(message.boundTick);
        }
        if (message.useNoBound === true) {
            writer.uint32(48).bool(message.useNoBound);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityNetInDirectionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tokenIn = reader.string();
                    break;
                case 3:
                    message.startTick = reader.int64();
                    break;
                case 4:
                    message.useCurTick = reader.bool();
                    break;
                case 5:
                    message.boundTick = reader.int64();
                    break;
                case 6:
                    message.useNoBound = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityNetInDirectionRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tokenIn = object.tokenIn ?? "";
        message.startTick = object.startTick !== undefined && object.startTick !== null ? BigInt(object.startTick.toString()) : BigInt(0);
        message.useCurTick = object.useCurTick ?? false;
        message.boundTick = object.boundTick !== undefined && object.boundTick !== null ? BigInt(object.boundTick.toString()) : BigInt(0);
        message.useNoBound = object.useNoBound ?? false;
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tokenIn: object.token_in,
            startTick: BigInt(object.start_tick),
            useCurTick: object.use_cur_tick,
            boundTick: BigInt(object.bound_tick),
            useNoBound: object.use_no_bound
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.token_in = message.tokenIn;
        obj.start_tick = message.startTick ? message.startTick.toString() : undefined;
        obj.use_cur_tick = message.useCurTick;
        obj.bound_tick = message.boundTick ? message.boundTick.toString() : undefined;
        obj.use_no_bound = message.useNoBound;
        return obj;
    },
    fromAminoMsg(object) {
        return LiquidityNetInDirectionRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-net-in-direction-request",
            value: LiquidityNetInDirectionRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return LiquidityNetInDirectionRequest.decode(message.value);
    },
    toProto(message) {
        return LiquidityNetInDirectionRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionRequest",
            value: LiquidityNetInDirectionRequest.encode(message).finish()
        };
    }
};
function createBaseLiquidityNetInDirectionResponse() {
    return {
        liquidityDepths: [],
        currentTick: BigInt(0),
        currentLiquidity: ""
    };
}
export const LiquidityNetInDirectionResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.liquidityDepths) {
            TickLiquidityNet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.currentTick !== BigInt(0)) {
            writer.uint32(16).int64(message.currentTick);
        }
        if (message.currentLiquidity !== "") {
            writer.uint32(26).string(Decimal.fromUserInput(message.currentLiquidity, 18).atomics);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityNetInDirectionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidityDepths.push(TickLiquidityNet.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.currentTick = reader.int64();
                    break;
                case 3:
                    message.currentLiquidity = Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityNetInDirectionResponse();
        message.liquidityDepths = object.liquidityDepths?.map(e => TickLiquidityNet.fromPartial(e)) || [];
        message.currentTick = object.currentTick !== undefined && object.currentTick !== null ? BigInt(object.currentTick.toString()) : BigInt(0);
        message.currentLiquidity = object.currentLiquidity ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            liquidityDepths: Array.isArray(object?.liquidity_depths) ? object.liquidity_depths.map((e) => TickLiquidityNet.fromAmino(e)) : [],
            currentTick: BigInt(object.current_tick),
            currentLiquidity: object.current_liquidity
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.liquidityDepths) {
            obj.liquidity_depths = message.liquidityDepths.map(e => e ? TickLiquidityNet.toAmino(e) : undefined);
        }
        else {
            obj.liquidity_depths = [];
        }
        obj.current_tick = message.currentTick ? message.currentTick.toString() : undefined;
        obj.current_liquidity = message.currentLiquidity;
        return obj;
    },
    fromAminoMsg(object) {
        return LiquidityNetInDirectionResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-net-in-direction-response",
            value: LiquidityNetInDirectionResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return LiquidityNetInDirectionResponse.decode(message.value);
    },
    toProto(message) {
        return LiquidityNetInDirectionResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityNetInDirectionResponse",
            value: LiquidityNetInDirectionResponse.encode(message).finish()
        };
    }
};
function createBaseLiquidityPerTickRangeRequest() {
    return {
        poolId: BigInt(0)
    };
}
export const LiquidityPerTickRangeRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityPerTickRangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityPerTickRangeRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return LiquidityPerTickRangeRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-per-tick-range-request",
            value: LiquidityPerTickRangeRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return LiquidityPerTickRangeRequest.decode(message.value);
    },
    toProto(message) {
        return LiquidityPerTickRangeRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeRequest",
            value: LiquidityPerTickRangeRequest.encode(message).finish()
        };
    }
};
function createBaseLiquidityPerTickRangeResponse() {
    return {
        liquidity: []
    };
}
export const LiquidityPerTickRangeResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.liquidity) {
            LiquidityDepthWithRange.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidityPerTickRangeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidity.push(LiquidityDepthWithRange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLiquidityPerTickRangeResponse();
        message.liquidity = object.liquidity?.map(e => LiquidityDepthWithRange.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            liquidity: Array.isArray(object?.liquidity) ? object.liquidity.map((e) => LiquidityDepthWithRange.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.liquidity) {
            obj.liquidity = message.liquidity.map(e => e ? LiquidityDepthWithRange.toAmino(e) : undefined);
        }
        else {
            obj.liquidity = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return LiquidityPerTickRangeResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/liquidity-per-tick-range-response",
            value: LiquidityPerTickRangeResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return LiquidityPerTickRangeResponse.decode(message.value);
    },
    toProto(message) {
        return LiquidityPerTickRangeResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.LiquidityPerTickRangeResponse",
            value: LiquidityPerTickRangeResponse.encode(message).finish()
        };
    }
};
function createBaseClaimableSpreadRewardsRequest() {
    return {
        positionId: BigInt(0)
    };
}
export const ClaimableSpreadRewardsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableSpreadRewardsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableSpreadRewardsRequest();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return ClaimableSpreadRewardsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-spread-rewards-request",
            value: ClaimableSpreadRewardsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return ClaimableSpreadRewardsRequest.decode(message.value);
    },
    toProto(message) {
        return ClaimableSpreadRewardsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsRequest",
            value: ClaimableSpreadRewardsRequest.encode(message).finish()
        };
    }
};
function createBaseClaimableSpreadRewardsResponse() {
    return {
        claimableSpreadRewards: []
    };
}
export const ClaimableSpreadRewardsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.claimableSpreadRewards) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableSpreadRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.claimableSpreadRewards.push(Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableSpreadRewardsResponse();
        message.claimableSpreadRewards = object.claimableSpreadRewards?.map(e => Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            claimableSpreadRewards: Array.isArray(object?.claimable_spread_rewards) ? object.claimable_spread_rewards.map((e) => Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.claimableSpreadRewards) {
            obj.claimable_spread_rewards = message.claimableSpreadRewards.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.claimable_spread_rewards = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return ClaimableSpreadRewardsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-spread-rewards-response",
            value: ClaimableSpreadRewardsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return ClaimableSpreadRewardsResponse.decode(message.value);
    },
    toProto(message) {
        return ClaimableSpreadRewardsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableSpreadRewardsResponse",
            value: ClaimableSpreadRewardsResponse.encode(message).finish()
        };
    }
};
function createBaseClaimableIncentivesRequest() {
    return {
        positionId: BigInt(0)
    };
}
export const ClaimableIncentivesRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableIncentivesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableIncentivesRequest();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return ClaimableIncentivesRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-incentives-request",
            value: ClaimableIncentivesRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return ClaimableIncentivesRequest.decode(message.value);
    },
    toProto(message) {
        return ClaimableIncentivesRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesRequest",
            value: ClaimableIncentivesRequest.encode(message).finish()
        };
    }
};
function createBaseClaimableIncentivesResponse() {
    return {
        claimableIncentives: [],
        forfeitedIncentives: []
    };
}
export const ClaimableIncentivesResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.claimableIncentives) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.forfeitedIncentives) {
            Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimableIncentivesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.claimableIncentives.push(Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.forfeitedIncentives.push(Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseClaimableIncentivesResponse();
        message.claimableIncentives = object.claimableIncentives?.map(e => Coin.fromPartial(e)) || [];
        message.forfeitedIncentives = object.forfeitedIncentives?.map(e => Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            claimableIncentives: Array.isArray(object?.claimable_incentives) ? object.claimable_incentives.map((e) => Coin.fromAmino(e)) : [],
            forfeitedIncentives: Array.isArray(object?.forfeited_incentives) ? object.forfeited_incentives.map((e) => Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.claimableIncentives) {
            obj.claimable_incentives = message.claimableIncentives.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.claimable_incentives = [];
        }
        if (message.forfeitedIncentives) {
            obj.forfeited_incentives = message.forfeitedIncentives.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.forfeited_incentives = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return ClaimableIncentivesResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/claimable-incentives-response",
            value: ClaimableIncentivesResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return ClaimableIncentivesResponse.decode(message.value);
    },
    toProto(message) {
        return ClaimableIncentivesResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.ClaimableIncentivesResponse",
            value: ClaimableIncentivesResponse.encode(message).finish()
        };
    }
};
function createBasePoolAccumulatorRewardsRequest() {
    return {
        poolId: BigInt(0)
    };
}
export const PoolAccumulatorRewardsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolAccumulatorRewardsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolAccumulatorRewardsRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return PoolAccumulatorRewardsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pool-accumulator-rewards-request",
            value: PoolAccumulatorRewardsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PoolAccumulatorRewardsRequest.decode(message.value);
    },
    toProto(message) {
        return PoolAccumulatorRewardsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsRequest",
            value: PoolAccumulatorRewardsRequest.encode(message).finish()
        };
    }
};
function createBasePoolAccumulatorRewardsResponse() {
    return {
        spreadRewardGrowthGlobal: [],
        uptimeGrowthGlobal: []
    };
}
export const PoolAccumulatorRewardsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.spreadRewardGrowthGlobal) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.uptimeGrowthGlobal) {
            UptimeTracker.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolAccumulatorRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spreadRewardGrowthGlobal.push(DecCoin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.uptimeGrowthGlobal.push(UptimeTracker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolAccumulatorRewardsResponse();
        message.spreadRewardGrowthGlobal = object.spreadRewardGrowthGlobal?.map(e => DecCoin.fromPartial(e)) || [];
        message.uptimeGrowthGlobal = object.uptimeGrowthGlobal?.map(e => UptimeTracker.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            spreadRewardGrowthGlobal: Array.isArray(object?.spread_reward_growth_global) ? object.spread_reward_growth_global.map((e) => DecCoin.fromAmino(e)) : [],
            uptimeGrowthGlobal: Array.isArray(object?.uptime_growth_global) ? object.uptime_growth_global.map((e) => UptimeTracker.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.spreadRewardGrowthGlobal) {
            obj.spread_reward_growth_global = message.spreadRewardGrowthGlobal.map(e => e ? DecCoin.toAmino(e) : undefined);
        }
        else {
            obj.spread_reward_growth_global = [];
        }
        if (message.uptimeGrowthGlobal) {
            obj.uptime_growth_global = message.uptimeGrowthGlobal.map(e => e ? UptimeTracker.toAmino(e) : undefined);
        }
        else {
            obj.uptime_growth_global = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return PoolAccumulatorRewardsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/pool-accumulator-rewards-response",
            value: PoolAccumulatorRewardsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PoolAccumulatorRewardsResponse.decode(message.value);
    },
    toProto(message) {
        return PoolAccumulatorRewardsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.PoolAccumulatorRewardsResponse",
            value: PoolAccumulatorRewardsResponse.encode(message).finish()
        };
    }
};
function createBaseTickAccumulatorTrackersRequest() {
    return {
        poolId: BigInt(0),
        tickIndex: BigInt(0)
    };
}
export const TickAccumulatorTrackersRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tickIndex !== BigInt(0)) {
            writer.uint32(16).int64(message.tickIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTickAccumulatorTrackersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tickIndex = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTickAccumulatorTrackersRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tickIndex = object.tickIndex !== undefined && object.tickIndex !== null ? BigInt(object.tickIndex.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tickIndex: BigInt(object.tick_index)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.tick_index = message.tickIndex ? message.tickIndex.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return TickAccumulatorTrackersRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/tick-accumulator-trackers-request",
            value: TickAccumulatorTrackersRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return TickAccumulatorTrackersRequest.decode(message.value);
    },
    toProto(message) {
        return TickAccumulatorTrackersRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersRequest",
            value: TickAccumulatorTrackersRequest.encode(message).finish()
        };
    }
};
function createBaseTickAccumulatorTrackersResponse() {
    return {
        spreadRewardGrowthOppositeDirectionOfLastTraversal: [],
        uptimeTrackers: []
    };
}
export const TickAccumulatorTrackersResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.spreadRewardGrowthOppositeDirectionOfLastTraversal) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.uptimeTrackers) {
            UptimeTracker.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTickAccumulatorTrackersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spreadRewardGrowthOppositeDirectionOfLastTraversal.push(DecCoin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.uptimeTrackers.push(UptimeTracker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTickAccumulatorTrackersResponse();
        message.spreadRewardGrowthOppositeDirectionOfLastTraversal = object.spreadRewardGrowthOppositeDirectionOfLastTraversal?.map(e => DecCoin.fromPartial(e)) || [];
        message.uptimeTrackers = object.uptimeTrackers?.map(e => UptimeTracker.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            spreadRewardGrowthOppositeDirectionOfLastTraversal: Array.isArray(object?.spread_reward_growth_opposite_direction_of_last_traversal) ? object.spread_reward_growth_opposite_direction_of_last_traversal.map((e) => DecCoin.fromAmino(e)) : [],
            uptimeTrackers: Array.isArray(object?.uptime_trackers) ? object.uptime_trackers.map((e) => UptimeTracker.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.spreadRewardGrowthOppositeDirectionOfLastTraversal) {
            obj.spread_reward_growth_opposite_direction_of_last_traversal = message.spreadRewardGrowthOppositeDirectionOfLastTraversal.map(e => e ? DecCoin.toAmino(e) : undefined);
        }
        else {
            obj.spread_reward_growth_opposite_direction_of_last_traversal = [];
        }
        if (message.uptimeTrackers) {
            obj.uptime_trackers = message.uptimeTrackers.map(e => e ? UptimeTracker.toAmino(e) : undefined);
        }
        else {
            obj.uptime_trackers = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return TickAccumulatorTrackersResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/tick-accumulator-trackers-response",
            value: TickAccumulatorTrackersResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return TickAccumulatorTrackersResponse.decode(message.value);
    },
    toProto(message) {
        return TickAccumulatorTrackersResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.TickAccumulatorTrackersResponse",
            value: TickAccumulatorTrackersResponse.encode(message).finish()
        };
    }
};
function createBaseIncentiveRecordsRequest() {
    return {
        poolId: BigInt(0),
        pagination: PageRequest.fromPartial({})
    };
}
export const IncentiveRecordsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecordsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecordsRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.pagination = object.pagination !== undefined && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            pagination: object?.pagination ? PageRequest.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.pagination = message.pagination ? PageRequest.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return IncentiveRecordsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-records-request",
            value: IncentiveRecordsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return IncentiveRecordsRequest.decode(message.value);
    },
    toProto(message) {
        return IncentiveRecordsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsRequest",
            value: IncentiveRecordsRequest.encode(message).finish()
        };
    }
};
function createBaseIncentiveRecordsResponse() {
    return {
        incentiveRecords: [],
        pagination: PageResponse.fromPartial({})
    };
}
export const IncentiveRecordsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.incentiveRecords) {
            IncentiveRecord.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentiveRecordsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.incentiveRecords.push(IncentiveRecord.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseIncentiveRecordsResponse();
        message.incentiveRecords = object.incentiveRecords?.map(e => IncentiveRecord.fromPartial(e)) || [];
        message.pagination = object.pagination !== undefined && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            incentiveRecords: Array.isArray(object?.incentive_records) ? object.incentive_records.map((e) => IncentiveRecord.fromAmino(e)) : [],
            pagination: object?.pagination ? PageResponse.fromAmino(object.pagination) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.incentiveRecords) {
            obj.incentive_records = message.incentiveRecords.map(e => e ? IncentiveRecord.toAmino(e) : undefined);
        }
        else {
            obj.incentive_records = [];
        }
        obj.pagination = message.pagination ? PageResponse.toAmino(message.pagination) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return IncentiveRecordsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/incentive-records-response",
            value: IncentiveRecordsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return IncentiveRecordsResponse.decode(message.value);
    },
    toProto(message) {
        return IncentiveRecordsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordsResponse",
            value: IncentiveRecordsResponse.encode(message).finish()
        };
    }
};
function createBaseCFMMPoolIdLinkFromConcentratedPoolIdRequest() {
    return {
        concentratedPoolId: BigInt(0)
    };
}
export const CFMMPoolIdLinkFromConcentratedPoolIdRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.concentratedPoolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.concentratedPoolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.concentratedPoolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdRequest();
        message.concentratedPoolId = object.concentratedPoolId !== undefined && object.concentratedPoolId !== null ? BigInt(object.concentratedPoolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            concentratedPoolId: BigInt(object.concentrated_pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.concentrated_pool_id = message.concentratedPoolId ? message.concentratedPoolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return CFMMPoolIdLinkFromConcentratedPoolIdRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/cfmmpool-id-link-from-concentrated-pool-id-request",
            value: CFMMPoolIdLinkFromConcentratedPoolIdRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return CFMMPoolIdLinkFromConcentratedPoolIdRequest.decode(message.value);
    },
    toProto(message) {
        return CFMMPoolIdLinkFromConcentratedPoolIdRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdRequest",
            value: CFMMPoolIdLinkFromConcentratedPoolIdRequest.encode(message).finish()
        };
    }
};
function createBaseCFMMPoolIdLinkFromConcentratedPoolIdResponse() {
    return {
        cfmmPoolId: BigInt(0)
    };
}
export const CFMMPoolIdLinkFromConcentratedPoolIdResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.cfmmPoolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.cfmmPoolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cfmmPoolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseCFMMPoolIdLinkFromConcentratedPoolIdResponse();
        message.cfmmPoolId = object.cfmmPoolId !== undefined && object.cfmmPoolId !== null ? BigInt(object.cfmmPoolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            cfmmPoolId: BigInt(object.cfmm_pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.cfmm_pool_id = message.cfmmPoolId ? message.cfmmPoolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return CFMMPoolIdLinkFromConcentratedPoolIdResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/cfmmpool-id-link-from-concentrated-pool-id-response",
            value: CFMMPoolIdLinkFromConcentratedPoolIdResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return CFMMPoolIdLinkFromConcentratedPoolIdResponse.decode(message.value);
    },
    toProto(message) {
        return CFMMPoolIdLinkFromConcentratedPoolIdResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.CFMMPoolIdLinkFromConcentratedPoolIdResponse",
            value: CFMMPoolIdLinkFromConcentratedPoolIdResponse.encode(message).finish()
        };
    }
};
function createBaseUserUnbondingPositionsRequest() {
    return {
        address: ""
    };
}
export const UserUnbondingPositionsRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsRequest",
    encode(message, writer = BinaryWriter.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserUnbondingPositionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserUnbondingPositionsRequest();
        message.address = object.address ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            address: object.address
        };
    },
    toAmino(message) {
        const obj = {};
        obj.address = message.address;
        return obj;
    },
    fromAminoMsg(object) {
        return UserUnbondingPositionsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-unbonding-positions-request",
            value: UserUnbondingPositionsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return UserUnbondingPositionsRequest.decode(message.value);
    },
    toProto(message) {
        return UserUnbondingPositionsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsRequest",
            value: UserUnbondingPositionsRequest.encode(message).finish()
        };
    }
};
function createBaseUserUnbondingPositionsResponse() {
    return {
        positionsWithPeriodLock: []
    };
}
export const UserUnbondingPositionsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.positionsWithPeriodLock) {
            PositionWithPeriodLock.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserUnbondingPositionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionsWithPeriodLock.push(PositionWithPeriodLock.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseUserUnbondingPositionsResponse();
        message.positionsWithPeriodLock = object.positionsWithPeriodLock?.map(e => PositionWithPeriodLock.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            positionsWithPeriodLock: Array.isArray(object?.positions_with_period_lock) ? object.positions_with_period_lock.map((e) => PositionWithPeriodLock.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.positionsWithPeriodLock) {
            obj.positions_with_period_lock = message.positionsWithPeriodLock.map(e => e ? PositionWithPeriodLock.toAmino(e) : undefined);
        }
        else {
            obj.positions_with_period_lock = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return UserUnbondingPositionsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/user-unbonding-positions-response",
            value: UserUnbondingPositionsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return UserUnbondingPositionsResponse.decode(message.value);
    },
    toProto(message) {
        return UserUnbondingPositionsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.UserUnbondingPositionsResponse",
            value: UserUnbondingPositionsResponse.encode(message).finish()
        };
    }
};
function createBaseGetTotalLiquidityRequest() {
    return {};
}
export const GetTotalLiquidityRequest = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityRequest",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalLiquidityRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseGetTotalLiquidityRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return GetTotalLiquidityRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/get-total-liquidity-request",
            value: GetTotalLiquidityRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetTotalLiquidityRequest.decode(message.value);
    },
    toProto(message) {
        return GetTotalLiquidityRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityRequest",
            value: GetTotalLiquidityRequest.encode(message).finish()
        };
    }
};
function createBaseGetTotalLiquidityResponse() {
    return {
        totalLiquidity: []
    };
}
export const GetTotalLiquidityResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.totalLiquidity) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalLiquidityResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalLiquidity.push(Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetTotalLiquidityResponse();
        message.totalLiquidity = object.totalLiquidity?.map(e => Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            totalLiquidity: Array.isArray(object?.total_liquidity) ? object.total_liquidity.map((e) => Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.totalLiquidity) {
            obj.total_liquidity = message.totalLiquidity.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.total_liquidity = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return GetTotalLiquidityResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/get-total-liquidity-response",
            value: GetTotalLiquidityResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetTotalLiquidityResponse.decode(message.value);
    },
    toProto(message) {
        return GetTotalLiquidityResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.GetTotalLiquidityResponse",
            value: GetTotalLiquidityResponse.encode(message).finish()
        };
    }
};
export const PoolI_InterfaceDecoder = (input) => {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const data = Any.decode(reader, reader.uint32());
    switch (data.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return Pool1.decode(data.value);
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return CosmWasmPool.decode(data.value);
        case "/osmosis.gamm.v1beta1.Pool":
            return Pool2.decode(data.value);
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return Pool3.decode(data.value);
        default:
            return data;
    }
};
export const PoolI_FromAmino = (content) => {
    switch (content.type) {
        case "osmosis/concentratedliquidity/pool":
            return Any.fromPartial({
                typeUrl: "/osmosis.concentratedliquidity.v1beta1.Pool",
                value: Pool1.encode(Pool1.fromPartial(Pool1.fromAmino(content.value))).finish()
            });
        case "osmosis/cosmwasmpool/cosm-wasm-pool":
            return Any.fromPartial({
                typeUrl: "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool",
                value: CosmWasmPool.encode(CosmWasmPool.fromPartial(CosmWasmPool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/BalancerPool":
            return Any.fromPartial({
                typeUrl: "/osmosis.gamm.v1beta1.Pool",
                value: Pool2.encode(Pool2.fromPartial(Pool2.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/StableswapPool":
            return Any.fromPartial({
                typeUrl: "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool",
                value: Pool3.encode(Pool3.fromPartial(Pool3.fromAmino(content.value))).finish()
            });
        default:
            return Any.fromAmino(content);
    }
};
export const PoolI_ToAmino = (content) => {
    switch (content.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return {
                type: "osmosis/concentratedliquidity/pool",
                value: Pool1.toAmino(Pool1.decode(content.value))
            };
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return {
                type: "osmosis/cosmwasmpool/cosm-wasm-pool",
                value: CosmWasmPool.toAmino(CosmWasmPool.decode(content.value))
            };
        case "/osmosis.gamm.v1beta1.Pool":
            return {
                type: "osmosis/gamm/BalancerPool",
                value: Pool2.toAmino(Pool2.decode(content.value))
            };
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return {
                type: "osmosis/gamm/StableswapPool",
                value: Pool3.toAmino(Pool3.decode(content.value))
            };
        default:
            return Any.toAmino(content);
    }
};
//# sourceMappingURL=query.js.map
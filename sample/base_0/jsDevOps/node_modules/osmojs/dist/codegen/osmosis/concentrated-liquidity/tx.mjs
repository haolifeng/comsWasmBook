import { Coin } from "../../cosmos/base/v1beta1/coin";
import { BinaryReader, BinaryWriter } from "../../binary";
import { Decimal } from "@cosmjs/math";
function createBaseMsgCreatePosition() {
    return {
        poolId: BigInt(0),
        sender: "",
        lowerTick: BigInt(0),
        upperTick: BigInt(0),
        tokensProvided: [],
        tokenMinAmount0: "",
        tokenMinAmount1: ""
    };
}
export const MsgCreatePosition = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCreatePosition",
    encode(message, writer = BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        if (message.lowerTick !== BigInt(0)) {
            writer.uint32(24).int64(message.lowerTick);
        }
        if (message.upperTick !== BigInt(0)) {
            writer.uint32(32).int64(message.upperTick);
        }
        for (const v of message.tokensProvided) {
            Coin.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.tokenMinAmount0 !== "") {
            writer.uint32(50).string(message.tokenMinAmount0);
        }
        if (message.tokenMinAmount1 !== "") {
            writer.uint32(58).string(message.tokenMinAmount1);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.sender = reader.string();
                    break;
                case 3:
                    message.lowerTick = reader.int64();
                    break;
                case 4:
                    message.upperTick = reader.int64();
                    break;
                case 5:
                    message.tokensProvided.push(Coin.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.tokenMinAmount0 = reader.string();
                    break;
                case 7:
                    message.tokenMinAmount1 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCreatePosition();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.sender = object.sender ?? "";
        message.lowerTick = object.lowerTick !== undefined && object.lowerTick !== null ? BigInt(object.lowerTick.toString()) : BigInt(0);
        message.upperTick = object.upperTick !== undefined && object.upperTick !== null ? BigInt(object.upperTick.toString()) : BigInt(0);
        message.tokensProvided = object.tokensProvided?.map(e => Coin.fromPartial(e)) || [];
        message.tokenMinAmount0 = object.tokenMinAmount0 ?? "";
        message.tokenMinAmount1 = object.tokenMinAmount1 ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            sender: object.sender,
            lowerTick: BigInt(object.lower_tick),
            upperTick: BigInt(object.upper_tick),
            tokensProvided: Array.isArray(object?.tokens_provided) ? object.tokens_provided.map((e) => Coin.fromAmino(e)) : [],
            tokenMinAmount0: object.token_min_amount0,
            tokenMinAmount1: object.token_min_amount1
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.sender = message.sender;
        obj.lower_tick = message.lowerTick ? message.lowerTick.toString() : undefined;
        obj.upper_tick = message.upperTick ? message.upperTick.toString() : undefined;
        if (message.tokensProvided) {
            obj.tokens_provided = message.tokensProvided.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.tokens_provided = [];
        }
        obj.token_min_amount0 = message.tokenMinAmount0;
        obj.token_min_amount1 = message.tokenMinAmount1;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCreatePosition.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/create-position",
            value: MsgCreatePosition.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgCreatePosition.decode(message.value);
    },
    toProto(message) {
        return MsgCreatePosition.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCreatePosition",
            value: MsgCreatePosition.encode(message).finish()
        };
    }
};
function createBaseMsgCreatePositionResponse() {
    return {
        positionId: BigInt(0),
        amount0: "",
        amount1: "",
        liquidityCreated: "",
        lowerTick: BigInt(0),
        upperTick: BigInt(0)
    };
}
export const MsgCreatePositionResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCreatePositionResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        if (message.amount0 !== "") {
            writer.uint32(18).string(message.amount0);
        }
        if (message.amount1 !== "") {
            writer.uint32(26).string(message.amount1);
        }
        if (message.liquidityCreated !== "") {
            writer.uint32(42).string(Decimal.fromUserInput(message.liquidityCreated, 18).atomics);
        }
        if (message.lowerTick !== BigInt(0)) {
            writer.uint32(48).int64(message.lowerTick);
        }
        if (message.upperTick !== BigInt(0)) {
            writer.uint32(56).int64(message.upperTick);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePositionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                case 2:
                    message.amount0 = reader.string();
                    break;
                case 3:
                    message.amount1 = reader.string();
                    break;
                case 5:
                    message.liquidityCreated = Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 6:
                    message.lowerTick = reader.int64();
                    break;
                case 7:
                    message.upperTick = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCreatePositionResponse();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        message.amount0 = object.amount0 ?? "";
        message.amount1 = object.amount1 ?? "";
        message.liquidityCreated = object.liquidityCreated ?? "";
        message.lowerTick = object.lowerTick !== undefined && object.lowerTick !== null ? BigInt(object.lowerTick.toString()) : BigInt(0);
        message.upperTick = object.upperTick !== undefined && object.upperTick !== null ? BigInt(object.upperTick.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id),
            amount0: object.amount0,
            amount1: object.amount1,
            liquidityCreated: object.liquidity_created,
            lowerTick: BigInt(object.lower_tick),
            upperTick: BigInt(object.upper_tick)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        obj.amount0 = message.amount0;
        obj.amount1 = message.amount1;
        obj.liquidity_created = message.liquidityCreated;
        obj.lower_tick = message.lowerTick ? message.lowerTick.toString() : undefined;
        obj.upper_tick = message.upperTick ? message.upperTick.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCreatePositionResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/create-position-response",
            value: MsgCreatePositionResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgCreatePositionResponse.decode(message.value);
    },
    toProto(message) {
        return MsgCreatePositionResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCreatePositionResponse",
            value: MsgCreatePositionResponse.encode(message).finish()
        };
    }
};
function createBaseMsgAddToPosition() {
    return {
        positionId: BigInt(0),
        sender: "",
        amount0: "",
        amount1: "",
        tokenMinAmount0: "",
        tokenMinAmount1: ""
    };
}
export const MsgAddToPosition = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgAddToPosition",
    encode(message, writer = BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        if (message.amount0 !== "") {
            writer.uint32(26).string(message.amount0);
        }
        if (message.amount1 !== "") {
            writer.uint32(34).string(message.amount1);
        }
        if (message.tokenMinAmount0 !== "") {
            writer.uint32(42).string(message.tokenMinAmount0);
        }
        if (message.tokenMinAmount1 !== "") {
            writer.uint32(50).string(message.tokenMinAmount1);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddToPosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                case 2:
                    message.sender = reader.string();
                    break;
                case 3:
                    message.amount0 = reader.string();
                    break;
                case 4:
                    message.amount1 = reader.string();
                    break;
                case 5:
                    message.tokenMinAmount0 = reader.string();
                    break;
                case 6:
                    message.tokenMinAmount1 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgAddToPosition();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        message.sender = object.sender ?? "";
        message.amount0 = object.amount0 ?? "";
        message.amount1 = object.amount1 ?? "";
        message.tokenMinAmount0 = object.tokenMinAmount0 ?? "";
        message.tokenMinAmount1 = object.tokenMinAmount1 ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id),
            sender: object.sender,
            amount0: object.amount0,
            amount1: object.amount1,
            tokenMinAmount0: object.token_min_amount0,
            tokenMinAmount1: object.token_min_amount1
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        obj.sender = message.sender;
        obj.amount0 = message.amount0;
        obj.amount1 = message.amount1;
        obj.token_min_amount0 = message.tokenMinAmount0;
        obj.token_min_amount1 = message.tokenMinAmount1;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgAddToPosition.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/add-to-position",
            value: MsgAddToPosition.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgAddToPosition.decode(message.value);
    },
    toProto(message) {
        return MsgAddToPosition.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgAddToPosition",
            value: MsgAddToPosition.encode(message).finish()
        };
    }
};
function createBaseMsgAddToPositionResponse() {
    return {
        positionId: BigInt(0),
        amount0: "",
        amount1: ""
    };
}
export const MsgAddToPositionResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgAddToPositionResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        if (message.amount0 !== "") {
            writer.uint32(18).string(message.amount0);
        }
        if (message.amount1 !== "") {
            writer.uint32(26).string(message.amount1);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddToPositionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                case 2:
                    message.amount0 = reader.string();
                    break;
                case 3:
                    message.amount1 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgAddToPositionResponse();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        message.amount0 = object.amount0 ?? "";
        message.amount1 = object.amount1 ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id),
            amount0: object.amount0,
            amount1: object.amount1
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        obj.amount0 = message.amount0;
        obj.amount1 = message.amount1;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgAddToPositionResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/add-to-position-response",
            value: MsgAddToPositionResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgAddToPositionResponse.decode(message.value);
    },
    toProto(message) {
        return MsgAddToPositionResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgAddToPositionResponse",
            value: MsgAddToPositionResponse.encode(message).finish()
        };
    }
};
function createBaseMsgWithdrawPosition() {
    return {
        positionId: BigInt(0),
        sender: "",
        liquidityAmount: ""
    };
}
export const MsgWithdrawPosition = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgWithdrawPosition",
    encode(message, writer = BinaryWriter.create()) {
        if (message.positionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.positionId);
        }
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        if (message.liquidityAmount !== "") {
            writer.uint32(26).string(Decimal.fromUserInput(message.liquidityAmount, 18).atomics);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawPosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.positionId = reader.uint64();
                    break;
                case 2:
                    message.sender = reader.string();
                    break;
                case 3:
                    message.liquidityAmount = Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgWithdrawPosition();
        message.positionId = object.positionId !== undefined && object.positionId !== null ? BigInt(object.positionId.toString()) : BigInt(0);
        message.sender = object.sender ?? "";
        message.liquidityAmount = object.liquidityAmount ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            positionId: BigInt(object.position_id),
            sender: object.sender,
            liquidityAmount: object.liquidity_amount
        };
    },
    toAmino(message) {
        const obj = {};
        obj.position_id = message.positionId ? message.positionId.toString() : undefined;
        obj.sender = message.sender;
        obj.liquidity_amount = message.liquidityAmount;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgWithdrawPosition.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/withdraw-position",
            value: MsgWithdrawPosition.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgWithdrawPosition.decode(message.value);
    },
    toProto(message) {
        return MsgWithdrawPosition.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgWithdrawPosition",
            value: MsgWithdrawPosition.encode(message).finish()
        };
    }
};
function createBaseMsgWithdrawPositionResponse() {
    return {
        amount0: "",
        amount1: ""
    };
}
export const MsgWithdrawPositionResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgWithdrawPositionResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.amount0 !== "") {
            writer.uint32(10).string(message.amount0);
        }
        if (message.amount1 !== "") {
            writer.uint32(18).string(message.amount1);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawPositionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount0 = reader.string();
                    break;
                case 2:
                    message.amount1 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgWithdrawPositionResponse();
        message.amount0 = object.amount0 ?? "";
        message.amount1 = object.amount1 ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            amount0: object.amount0,
            amount1: object.amount1
        };
    },
    toAmino(message) {
        const obj = {};
        obj.amount0 = message.amount0;
        obj.amount1 = message.amount1;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgWithdrawPositionResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/withdraw-position-response",
            value: MsgWithdrawPositionResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgWithdrawPositionResponse.decode(message.value);
    },
    toProto(message) {
        return MsgWithdrawPositionResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgWithdrawPositionResponse",
            value: MsgWithdrawPositionResponse.encode(message).finish()
        };
    }
};
function createBaseMsgCollectSpreadRewards() {
    return {
        positionIds: [],
        sender: ""
    };
}
export const MsgCollectSpreadRewards = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectSpreadRewards",
    encode(message, writer = BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.positionIds) {
            writer.uint64(v);
        }
        writer.ldelim();
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCollectSpreadRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.positionIds.push(reader.uint64());
                        }
                    }
                    else {
                        message.positionIds.push(reader.uint64());
                    }
                    break;
                case 2:
                    message.sender = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCollectSpreadRewards();
        message.positionIds = object.positionIds?.map(e => BigInt(e.toString())) || [];
        message.sender = object.sender ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            positionIds: Array.isArray(object?.position_ids) ? object.position_ids.map((e) => BigInt(e)) : [],
            sender: object.sender
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.positionIds) {
            obj.position_ids = message.positionIds.map(e => e.toString());
        }
        else {
            obj.position_ids = [];
        }
        obj.sender = message.sender;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCollectSpreadRewards.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/collect-spread-rewards",
            value: MsgCollectSpreadRewards.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgCollectSpreadRewards.decode(message.value);
    },
    toProto(message) {
        return MsgCollectSpreadRewards.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectSpreadRewards",
            value: MsgCollectSpreadRewards.encode(message).finish()
        };
    }
};
function createBaseMsgCollectSpreadRewardsResponse() {
    return {
        collectedSpreadRewards: []
    };
}
export const MsgCollectSpreadRewardsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectSpreadRewardsResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.collectedSpreadRewards) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCollectSpreadRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectedSpreadRewards.push(Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCollectSpreadRewardsResponse();
        message.collectedSpreadRewards = object.collectedSpreadRewards?.map(e => Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            collectedSpreadRewards: Array.isArray(object?.collected_spread_rewards) ? object.collected_spread_rewards.map((e) => Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.collectedSpreadRewards) {
            obj.collected_spread_rewards = message.collectedSpreadRewards.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.collected_spread_rewards = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCollectSpreadRewardsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/collect-spread-rewards-response",
            value: MsgCollectSpreadRewardsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgCollectSpreadRewardsResponse.decode(message.value);
    },
    toProto(message) {
        return MsgCollectSpreadRewardsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectSpreadRewardsResponse",
            value: MsgCollectSpreadRewardsResponse.encode(message).finish()
        };
    }
};
function createBaseMsgCollectIncentives() {
    return {
        positionIds: [],
        sender: ""
    };
}
export const MsgCollectIncentives = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectIncentives",
    encode(message, writer = BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.positionIds) {
            writer.uint64(v);
        }
        writer.ldelim();
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCollectIncentives();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.positionIds.push(reader.uint64());
                        }
                    }
                    else {
                        message.positionIds.push(reader.uint64());
                    }
                    break;
                case 2:
                    message.sender = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCollectIncentives();
        message.positionIds = object.positionIds?.map(e => BigInt(e.toString())) || [];
        message.sender = object.sender ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            positionIds: Array.isArray(object?.position_ids) ? object.position_ids.map((e) => BigInt(e)) : [],
            sender: object.sender
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.positionIds) {
            obj.position_ids = message.positionIds.map(e => e.toString());
        }
        else {
            obj.position_ids = [];
        }
        obj.sender = message.sender;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCollectIncentives.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/collect-incentives",
            value: MsgCollectIncentives.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgCollectIncentives.decode(message.value);
    },
    toProto(message) {
        return MsgCollectIncentives.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectIncentives",
            value: MsgCollectIncentives.encode(message).finish()
        };
    }
};
function createBaseMsgCollectIncentivesResponse() {
    return {
        collectedIncentives: [],
        forfeitedIncentives: []
    };
}
export const MsgCollectIncentivesResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectIncentivesResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.collectedIncentives) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.forfeitedIncentives) {
            Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCollectIncentivesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.collectedIncentives.push(Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.forfeitedIncentives.push(Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgCollectIncentivesResponse();
        message.collectedIncentives = object.collectedIncentives?.map(e => Coin.fromPartial(e)) || [];
        message.forfeitedIncentives = object.forfeitedIncentives?.map(e => Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            collectedIncentives: Array.isArray(object?.collected_incentives) ? object.collected_incentives.map((e) => Coin.fromAmino(e)) : [],
            forfeitedIncentives: Array.isArray(object?.forfeited_incentives) ? object.forfeited_incentives.map((e) => Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.collectedIncentives) {
            obj.collected_incentives = message.collectedIncentives.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.collected_incentives = [];
        }
        if (message.forfeitedIncentives) {
            obj.forfeited_incentives = message.forfeitedIncentives.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.forfeited_incentives = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return MsgCollectIncentivesResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/collect-incentives-response",
            value: MsgCollectIncentivesResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgCollectIncentivesResponse.decode(message.value);
    },
    toProto(message) {
        return MsgCollectIncentivesResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgCollectIncentivesResponse",
            value: MsgCollectIncentivesResponse.encode(message).finish()
        };
    }
};
function createBaseMsgFungifyChargedPositions() {
    return {
        positionIds: [],
        sender: ""
    };
}
export const MsgFungifyChargedPositions = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgFungifyChargedPositions",
    encode(message, writer = BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.positionIds) {
            writer.uint64(v);
        }
        writer.ldelim();
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgFungifyChargedPositions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.positionIds.push(reader.uint64());
                        }
                    }
                    else {
                        message.positionIds.push(reader.uint64());
                    }
                    break;
                case 2:
                    message.sender = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgFungifyChargedPositions();
        message.positionIds = object.positionIds?.map(e => BigInt(e.toString())) || [];
        message.sender = object.sender ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            positionIds: Array.isArray(object?.position_ids) ? object.position_ids.map((e) => BigInt(e)) : [],
            sender: object.sender
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.positionIds) {
            obj.position_ids = message.positionIds.map(e => e.toString());
        }
        else {
            obj.position_ids = [];
        }
        obj.sender = message.sender;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgFungifyChargedPositions.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/fungify-charged-positions",
            value: MsgFungifyChargedPositions.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgFungifyChargedPositions.decode(message.value);
    },
    toProto(message) {
        return MsgFungifyChargedPositions.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgFungifyChargedPositions",
            value: MsgFungifyChargedPositions.encode(message).finish()
        };
    }
};
function createBaseMsgFungifyChargedPositionsResponse() {
    return {
        newPositionId: BigInt(0)
    };
}
export const MsgFungifyChargedPositionsResponse = {
    typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgFungifyChargedPositionsResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.newPositionId !== BigInt(0)) {
            writer.uint32(8).uint64(message.newPositionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgFungifyChargedPositionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.newPositionId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgFungifyChargedPositionsResponse();
        message.newPositionId = object.newPositionId !== undefined && object.newPositionId !== null ? BigInt(object.newPositionId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            newPositionId: BigInt(object.new_position_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.new_position_id = message.newPositionId ? message.newPositionId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return MsgFungifyChargedPositionsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/concentratedliquidity/fungify-charged-positions-response",
            value: MsgFungifyChargedPositionsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return MsgFungifyChargedPositionsResponse.decode(message.value);
    },
    toProto(message) {
        return MsgFungifyChargedPositionsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.concentratedliquidity.v1beta1.MsgFungifyChargedPositionsResponse",
            value: MsgFungifyChargedPositionsResponse.encode(message).finish()
        };
    }
};
//# sourceMappingURL=tx.js.map
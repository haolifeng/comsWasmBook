import { Coin } from "../../../../cosmos/base/v1beta1/coin";
import { BinaryReader, BinaryWriter } from "../../../../binary";
import { Decimal } from "@cosmjs/math";
function createBaseGetSwapFeeQueryMsg() {
    return {
        getSwapFee: EmptyStruct.fromPartial({})
    };
}
export const GetSwapFeeQueryMsg = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetSwapFeeQueryMsg",
    encode(message, writer = BinaryWriter.create()) {
        if (message.getSwapFee !== undefined) {
            EmptyStruct.encode(message.getSwapFee, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSwapFeeQueryMsg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.getSwapFee = EmptyStruct.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetSwapFeeQueryMsg();
        message.getSwapFee = object.getSwapFee !== undefined && object.getSwapFee !== null ? EmptyStruct.fromPartial(object.getSwapFee) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            getSwapFee: object?.get_swap_fee ? EmptyStruct.fromAmino(object.get_swap_fee) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.get_swap_fee = message.getSwapFee ? EmptyStruct.toAmino(message.getSwapFee) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return GetSwapFeeQueryMsg.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/get-swap-fee-query-msg",
            value: GetSwapFeeQueryMsg.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetSwapFeeQueryMsg.decode(message.value);
    },
    toProto(message) {
        return GetSwapFeeQueryMsg.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetSwapFeeQueryMsg",
            value: GetSwapFeeQueryMsg.encode(message).finish()
        };
    }
};
function createBaseGetSwapFeeQueryMsgResponse() {
    return {
        swapFee: ""
    };
}
export const GetSwapFeeQueryMsgResponse = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetSwapFeeQueryMsgResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.swapFee !== "") {
            writer.uint32(26).string(Decimal.fromUserInput(message.swapFee, 18).atomics);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSwapFeeQueryMsgResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.swapFee = Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetSwapFeeQueryMsgResponse();
        message.swapFee = object.swapFee ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            swapFee: object.swap_fee
        };
    },
    toAmino(message) {
        const obj = {};
        obj.swap_fee = message.swapFee;
        return obj;
    },
    fromAminoMsg(object) {
        return GetSwapFeeQueryMsgResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/get-swap-fee-query-msg-response",
            value: GetSwapFeeQueryMsgResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetSwapFeeQueryMsgResponse.decode(message.value);
    },
    toProto(message) {
        return GetSwapFeeQueryMsgResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetSwapFeeQueryMsgResponse",
            value: GetSwapFeeQueryMsgResponse.encode(message).finish()
        };
    }
};
function createBaseSpotPrice() {
    return {
        quoteAssetDenom: "",
        baseAssetDenom: ""
    };
}
export const SpotPrice = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.SpotPrice",
    encode(message, writer = BinaryWriter.create()) {
        if (message.quoteAssetDenom !== "") {
            writer.uint32(10).string(message.quoteAssetDenom);
        }
        if (message.baseAssetDenom !== "") {
            writer.uint32(18).string(message.baseAssetDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpotPrice();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.quoteAssetDenom = reader.string();
                    break;
                case 2:
                    message.baseAssetDenom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseSpotPrice();
        message.quoteAssetDenom = object.quoteAssetDenom ?? "";
        message.baseAssetDenom = object.baseAssetDenom ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            quoteAssetDenom: object.quote_asset_denom,
            baseAssetDenom: object.base_asset_denom
        };
    },
    toAmino(message) {
        const obj = {};
        obj.quote_asset_denom = message.quoteAssetDenom;
        obj.base_asset_denom = message.baseAssetDenom;
        return obj;
    },
    fromAminoMsg(object) {
        return SpotPrice.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/spot-price",
            value: SpotPrice.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return SpotPrice.decode(message.value);
    },
    toProto(message) {
        return SpotPrice.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.SpotPrice",
            value: SpotPrice.encode(message).finish()
        };
    }
};
function createBaseSpotPriceQueryMsg() {
    return {
        spotPrice: SpotPrice.fromPartial({})
    };
}
export const SpotPriceQueryMsg = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.SpotPriceQueryMsg",
    encode(message, writer = BinaryWriter.create()) {
        if (message.spotPrice !== undefined) {
            SpotPrice.encode(message.spotPrice, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpotPriceQueryMsg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spotPrice = SpotPrice.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseSpotPriceQueryMsg();
        message.spotPrice = object.spotPrice !== undefined && object.spotPrice !== null ? SpotPrice.fromPartial(object.spotPrice) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            spotPrice: object?.spot_price ? SpotPrice.fromAmino(object.spot_price) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.spot_price = message.spotPrice ? SpotPrice.toAmino(message.spotPrice) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return SpotPriceQueryMsg.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/spot-price-query-msg",
            value: SpotPriceQueryMsg.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return SpotPriceQueryMsg.decode(message.value);
    },
    toProto(message) {
        return SpotPriceQueryMsg.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.SpotPriceQueryMsg",
            value: SpotPriceQueryMsg.encode(message).finish()
        };
    }
};
function createBaseSpotPriceQueryMsgResponse() {
    return {
        spotPrice: ""
    };
}
export const SpotPriceQueryMsgResponse = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.SpotPriceQueryMsgResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.spotPrice !== "") {
            writer.uint32(10).string(message.spotPrice);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpotPriceQueryMsgResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spotPrice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseSpotPriceQueryMsgResponse();
        message.spotPrice = object.spotPrice ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            spotPrice: object.spot_price
        };
    },
    toAmino(message) {
        const obj = {};
        obj.spot_price = message.spotPrice;
        return obj;
    },
    fromAminoMsg(object) {
        return SpotPriceQueryMsgResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/spot-price-query-msg-response",
            value: SpotPriceQueryMsgResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return SpotPriceQueryMsgResponse.decode(message.value);
    },
    toProto(message) {
        return SpotPriceQueryMsgResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.SpotPriceQueryMsgResponse",
            value: SpotPriceQueryMsgResponse.encode(message).finish()
        };
    }
};
function createBaseEmptyStruct() {
    return {};
}
export const EmptyStruct = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.EmptyStruct",
    encode(_, writer = BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmptyStruct();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseEmptyStruct();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return EmptyStruct.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/empty-struct",
            value: EmptyStruct.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return EmptyStruct.decode(message.value);
    },
    toProto(message) {
        return EmptyStruct.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.EmptyStruct",
            value: EmptyStruct.encode(message).finish()
        };
    }
};
function createBaseGetTotalPoolLiquidityQueryMsg() {
    return {
        getTotalPoolLiquidity: EmptyStruct.fromPartial({})
    };
}
export const GetTotalPoolLiquidityQueryMsg = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalPoolLiquidityQueryMsg",
    encode(message, writer = BinaryWriter.create()) {
        if (message.getTotalPoolLiquidity !== undefined) {
            EmptyStruct.encode(message.getTotalPoolLiquidity, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalPoolLiquidityQueryMsg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.getTotalPoolLiquidity = EmptyStruct.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetTotalPoolLiquidityQueryMsg();
        message.getTotalPoolLiquidity = object.getTotalPoolLiquidity !== undefined && object.getTotalPoolLiquidity !== null ? EmptyStruct.fromPartial(object.getTotalPoolLiquidity) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            getTotalPoolLiquidity: object?.get_total_pool_liquidity ? EmptyStruct.fromAmino(object.get_total_pool_liquidity) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.get_total_pool_liquidity = message.getTotalPoolLiquidity ? EmptyStruct.toAmino(message.getTotalPoolLiquidity) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return GetTotalPoolLiquidityQueryMsg.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/get-total-pool-liquidity-query-msg",
            value: GetTotalPoolLiquidityQueryMsg.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetTotalPoolLiquidityQueryMsg.decode(message.value);
    },
    toProto(message) {
        return GetTotalPoolLiquidityQueryMsg.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalPoolLiquidityQueryMsg",
            value: GetTotalPoolLiquidityQueryMsg.encode(message).finish()
        };
    }
};
function createBaseGetTotalPoolLiquidityQueryMsgResponse() {
    return {
        totalPoolLiquidity: []
    };
}
export const GetTotalPoolLiquidityQueryMsgResponse = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalPoolLiquidityQueryMsgResponse",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.totalPoolLiquidity) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalPoolLiquidityQueryMsgResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalPoolLiquidity.push(Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetTotalPoolLiquidityQueryMsgResponse();
        message.totalPoolLiquidity = object.totalPoolLiquidity?.map(e => Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            totalPoolLiquidity: Array.isArray(object?.total_pool_liquidity) ? object.total_pool_liquidity.map((e) => Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.totalPoolLiquidity) {
            obj.total_pool_liquidity = message.totalPoolLiquidity.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.total_pool_liquidity = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return GetTotalPoolLiquidityQueryMsgResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/get-total-pool-liquidity-query-msg-response",
            value: GetTotalPoolLiquidityQueryMsgResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetTotalPoolLiquidityQueryMsgResponse.decode(message.value);
    },
    toProto(message) {
        return GetTotalPoolLiquidityQueryMsgResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalPoolLiquidityQueryMsgResponse",
            value: GetTotalPoolLiquidityQueryMsgResponse.encode(message).finish()
        };
    }
};
function createBaseGetTotalSharesQueryMsg() {
    return {
        getTotalShares: EmptyStruct.fromPartial({})
    };
}
export const GetTotalSharesQueryMsg = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalSharesQueryMsg",
    encode(message, writer = BinaryWriter.create()) {
        if (message.getTotalShares !== undefined) {
            EmptyStruct.encode(message.getTotalShares, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalSharesQueryMsg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.getTotalShares = EmptyStruct.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetTotalSharesQueryMsg();
        message.getTotalShares = object.getTotalShares !== undefined && object.getTotalShares !== null ? EmptyStruct.fromPartial(object.getTotalShares) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            getTotalShares: object?.get_total_shares ? EmptyStruct.fromAmino(object.get_total_shares) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.get_total_shares = message.getTotalShares ? EmptyStruct.toAmino(message.getTotalShares) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return GetTotalSharesQueryMsg.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/get-total-shares-query-msg",
            value: GetTotalSharesQueryMsg.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetTotalSharesQueryMsg.decode(message.value);
    },
    toProto(message) {
        return GetTotalSharesQueryMsg.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalSharesQueryMsg",
            value: GetTotalSharesQueryMsg.encode(message).finish()
        };
    }
};
function createBaseGetTotalSharesQueryMsgResponse() {
    return {
        totalShares: ""
    };
}
export const GetTotalSharesQueryMsgResponse = {
    typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalSharesQueryMsgResponse",
    encode(message, writer = BinaryWriter.create()) {
        if (message.totalShares !== "") {
            writer.uint32(10).string(message.totalShares);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetTotalSharesQueryMsgResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalShares = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseGetTotalSharesQueryMsgResponse();
        message.totalShares = object.totalShares ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            totalShares: object.total_shares
        };
    },
    toAmino(message) {
        const obj = {};
        obj.total_shares = message.totalShares;
        return obj;
    },
    fromAminoMsg(object) {
        return GetTotalSharesQueryMsgResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/cosmwasmpool/get-total-shares-query-msg-response",
            value: GetTotalSharesQueryMsgResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return GetTotalSharesQueryMsgResponse.decode(message.value);
    },
    toProto(message) {
        return GetTotalSharesQueryMsgResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.cosmwasmpool.v1beta1.GetTotalSharesQueryMsgResponse",
            value: GetTotalSharesQueryMsgResponse.encode(message).finish()
        };
    }
};
//# sourceMappingURL=pool_query_msg.js.map
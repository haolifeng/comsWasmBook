"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolI_ToAmino = exports.PoolI_FromAmino = exports.PoolI_InterfaceDecoder = exports.TotalLiquidityResponse = exports.TotalLiquidityRequest = exports.TotalPoolLiquidityResponse = exports.TotalPoolLiquidityRequest = exports.SpotPriceResponse = exports.SpotPriceRequest = exports.AllPoolsResponse = exports.AllPoolsRequest = exports.PoolResponse = exports.PoolRequest = exports.NumPoolsResponse = exports.NumPoolsRequest = exports.EstimateSwapExactAmountOutResponse = exports.EstimateSinglePoolSwapExactAmountOutRequest = exports.EstimateSwapExactAmountOutRequest = exports.EstimateSwapExactAmountInResponse = exports.EstimateSinglePoolSwapExactAmountInRequest = exports.EstimateSwapExactAmountInRequest = exports.ParamsResponse = exports.ParamsRequest = void 0;
const swap_route_1 = require("./swap_route");
const genesis_1 = require("./genesis");
const any_1 = require("../../../google/protobuf/any");
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const pool_1 = require("../../concentrated-liquidity/pool");
const pool_2 = require("../../cosmwasmpool/v1beta1/model/pool");
const balancerPool_1 = require("../../gamm/pool-models/balancer/balancerPool");
const stableswap_pool_1 = require("../../gamm/pool-models/stableswap/stableswap_pool");
const binary_1 = require("../../../binary");
function createBaseParamsRequest() {
    return {};
}
exports.ParamsRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.ParamsRequest",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParamsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseParamsRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ParamsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/params-request",
            value: exports.ParamsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ParamsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.ParamsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.ParamsRequest",
            value: exports.ParamsRequest.encode(message).finish()
        };
    }
};
function createBaseParamsResponse() {
    return {
        params: genesis_1.Params.fromPartial({})
    };
}
exports.ParamsResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.ParamsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== undefined) {
            genesis_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = genesis_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseParamsResponse();
        message.params = object.params !== undefined && object.params !== null ? genesis_1.Params.fromPartial(object.params) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            params: object?.params ? genesis_1.Params.fromAmino(object.params) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.params = message.params ? genesis_1.Params.toAmino(message.params) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ParamsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/params-response",
            value: exports.ParamsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.ParamsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.ParamsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.ParamsResponse",
            value: exports.ParamsResponse.encode(message).finish()
        };
    }
};
function createBaseEstimateSwapExactAmountInRequest() {
    return {
        poolId: BigInt(0),
        tokenIn: "",
        routes: []
    };
}
exports.EstimateSwapExactAmountInRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(16).uint64(message.poolId);
        }
        if (message.tokenIn !== "") {
            writer.uint32(26).string(message.tokenIn);
        }
        for (const v of message.routes) {
            swap_route_1.SwapAmountInRoute.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEstimateSwapExactAmountInRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.poolId = reader.uint64();
                    break;
                case 3:
                    message.tokenIn = reader.string();
                    break;
                case 4:
                    message.routes.push(swap_route_1.SwapAmountInRoute.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseEstimateSwapExactAmountInRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tokenIn = object.tokenIn ?? "";
        message.routes = object.routes?.map(e => swap_route_1.SwapAmountInRoute.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tokenIn: object.token_in,
            routes: Array.isArray(object?.routes) ? object.routes.map((e) => swap_route_1.SwapAmountInRoute.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.token_in = message.tokenIn;
        if (message.routes) {
            obj.routes = message.routes.map(e => e ? swap_route_1.SwapAmountInRoute.toAmino(e) : undefined);
        }
        else {
            obj.routes = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.EstimateSwapExactAmountInRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/estimate-swap-exact-amount-in-request",
            value: exports.EstimateSwapExactAmountInRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.EstimateSwapExactAmountInRequest.decode(message.value);
    },
    toProto(message) {
        return exports.EstimateSwapExactAmountInRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInRequest",
            value: exports.EstimateSwapExactAmountInRequest.encode(message).finish()
        };
    }
};
function createBaseEstimateSinglePoolSwapExactAmountInRequest() {
    return {
        poolId: BigInt(0),
        tokenIn: "",
        tokenOutDenom: ""
    };
}
exports.EstimateSinglePoolSwapExactAmountInRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountInRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tokenIn !== "") {
            writer.uint32(18).string(message.tokenIn);
        }
        if (message.tokenOutDenom !== "") {
            writer.uint32(26).string(message.tokenOutDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEstimateSinglePoolSwapExactAmountInRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tokenIn = reader.string();
                    break;
                case 3:
                    message.tokenOutDenom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseEstimateSinglePoolSwapExactAmountInRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tokenIn = object.tokenIn ?? "";
        message.tokenOutDenom = object.tokenOutDenom ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tokenIn: object.token_in,
            tokenOutDenom: object.token_out_denom
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.token_in = message.tokenIn;
        obj.token_out_denom = message.tokenOutDenom;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.EstimateSinglePoolSwapExactAmountInRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/estimate-single-pool-swap-exact-amount-in-request",
            value: exports.EstimateSinglePoolSwapExactAmountInRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.EstimateSinglePoolSwapExactAmountInRequest.decode(message.value);
    },
    toProto(message) {
        return exports.EstimateSinglePoolSwapExactAmountInRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountInRequest",
            value: exports.EstimateSinglePoolSwapExactAmountInRequest.encode(message).finish()
        };
    }
};
function createBaseEstimateSwapExactAmountInResponse() {
    return {
        tokenOutAmount: ""
    };
}
exports.EstimateSwapExactAmountInResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tokenOutAmount !== "") {
            writer.uint32(10).string(message.tokenOutAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEstimateSwapExactAmountInResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tokenOutAmount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseEstimateSwapExactAmountInResponse();
        message.tokenOutAmount = object.tokenOutAmount ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            tokenOutAmount: object.token_out_amount
        };
    },
    toAmino(message) {
        const obj = {};
        obj.token_out_amount = message.tokenOutAmount;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.EstimateSwapExactAmountInResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/estimate-swap-exact-amount-in-response",
            value: exports.EstimateSwapExactAmountInResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.EstimateSwapExactAmountInResponse.decode(message.value);
    },
    toProto(message) {
        return exports.EstimateSwapExactAmountInResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInResponse",
            value: exports.EstimateSwapExactAmountInResponse.encode(message).finish()
        };
    }
};
function createBaseEstimateSwapExactAmountOutRequest() {
    return {
        poolId: BigInt(0),
        routes: [],
        tokenOut: ""
    };
}
exports.EstimateSwapExactAmountOutRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(16).uint64(message.poolId);
        }
        for (const v of message.routes) {
            swap_route_1.SwapAmountOutRoute.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.tokenOut !== "") {
            writer.uint32(34).string(message.tokenOut);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEstimateSwapExactAmountOutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.poolId = reader.uint64();
                    break;
                case 3:
                    message.routes.push(swap_route_1.SwapAmountOutRoute.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.tokenOut = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseEstimateSwapExactAmountOutRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.routes = object.routes?.map(e => swap_route_1.SwapAmountOutRoute.fromPartial(e)) || [];
        message.tokenOut = object.tokenOut ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            routes: Array.isArray(object?.routes) ? object.routes.map((e) => swap_route_1.SwapAmountOutRoute.fromAmino(e)) : [],
            tokenOut: object.token_out
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        if (message.routes) {
            obj.routes = message.routes.map(e => e ? swap_route_1.SwapAmountOutRoute.toAmino(e) : undefined);
        }
        else {
            obj.routes = [];
        }
        obj.token_out = message.tokenOut;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.EstimateSwapExactAmountOutRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/estimate-swap-exact-amount-out-request",
            value: exports.EstimateSwapExactAmountOutRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.EstimateSwapExactAmountOutRequest.decode(message.value);
    },
    toProto(message) {
        return exports.EstimateSwapExactAmountOutRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutRequest",
            value: exports.EstimateSwapExactAmountOutRequest.encode(message).finish()
        };
    }
};
function createBaseEstimateSinglePoolSwapExactAmountOutRequest() {
    return {
        poolId: BigInt(0),
        tokenInDenom: "",
        tokenOut: ""
    };
}
exports.EstimateSinglePoolSwapExactAmountOutRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountOutRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.tokenInDenom !== "") {
            writer.uint32(18).string(message.tokenInDenom);
        }
        if (message.tokenOut !== "") {
            writer.uint32(26).string(message.tokenOut);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEstimateSinglePoolSwapExactAmountOutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.tokenInDenom = reader.string();
                    break;
                case 3:
                    message.tokenOut = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseEstimateSinglePoolSwapExactAmountOutRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.tokenInDenom = object.tokenInDenom ?? "";
        message.tokenOut = object.tokenOut ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            tokenInDenom: object.token_in_denom,
            tokenOut: object.token_out
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.token_in_denom = message.tokenInDenom;
        obj.token_out = message.tokenOut;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.EstimateSinglePoolSwapExactAmountOutRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/estimate-single-pool-swap-exact-amount-out-request",
            value: exports.EstimateSinglePoolSwapExactAmountOutRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.EstimateSinglePoolSwapExactAmountOutRequest.decode(message.value);
    },
    toProto(message) {
        return exports.EstimateSinglePoolSwapExactAmountOutRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountOutRequest",
            value: exports.EstimateSinglePoolSwapExactAmountOutRequest.encode(message).finish()
        };
    }
};
function createBaseEstimateSwapExactAmountOutResponse() {
    return {
        tokenInAmount: ""
    };
}
exports.EstimateSwapExactAmountOutResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tokenInAmount !== "") {
            writer.uint32(10).string(message.tokenInAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEstimateSwapExactAmountOutResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tokenInAmount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseEstimateSwapExactAmountOutResponse();
        message.tokenInAmount = object.tokenInAmount ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            tokenInAmount: object.token_in_amount
        };
    },
    toAmino(message) {
        const obj = {};
        obj.token_in_amount = message.tokenInAmount;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.EstimateSwapExactAmountOutResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/estimate-swap-exact-amount-out-response",
            value: exports.EstimateSwapExactAmountOutResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.EstimateSwapExactAmountOutResponse.decode(message.value);
    },
    toProto(message) {
        return exports.EstimateSwapExactAmountOutResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutResponse",
            value: exports.EstimateSwapExactAmountOutResponse.encode(message).finish()
        };
    }
};
function createBaseNumPoolsRequest() {
    return {};
}
exports.NumPoolsRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.NumPoolsRequest",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNumPoolsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseNumPoolsRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.NumPoolsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/num-pools-request",
            value: exports.NumPoolsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.NumPoolsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.NumPoolsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.NumPoolsRequest",
            value: exports.NumPoolsRequest.encode(message).finish()
        };
    }
};
function createBaseNumPoolsResponse() {
    return {
        numPools: BigInt(0)
    };
}
exports.NumPoolsResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.NumPoolsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.numPools !== BigInt(0)) {
            writer.uint32(8).uint64(message.numPools);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNumPoolsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.numPools = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseNumPoolsResponse();
        message.numPools = object.numPools !== undefined && object.numPools !== null ? BigInt(object.numPools.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            numPools: BigInt(object.num_pools)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.num_pools = message.numPools ? message.numPools.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.NumPoolsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/num-pools-response",
            value: exports.NumPoolsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.NumPoolsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.NumPoolsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.NumPoolsResponse",
            value: exports.NumPoolsResponse.encode(message).finish()
        };
    }
};
function createBasePoolRequest() {
    return {
        poolId: BigInt(0)
    };
}
exports.PoolRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.PoolRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PoolRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/pool-request",
            value: exports.PoolRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PoolRequest.decode(message.value);
    },
    toProto(message) {
        return exports.PoolRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.PoolRequest",
            value: exports.PoolRequest.encode(message).finish()
        };
    }
};
function createBasePoolResponse() {
    return {
        pool: undefined
    };
}
exports.PoolResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.PoolResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pool !== undefined) {
            any_1.Any.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = (0, exports.PoolI_InterfaceDecoder)(reader);
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolResponse();
        message.pool = object.pool !== undefined && object.pool !== null ? any_1.Any.fromPartial(object.pool) : undefined;
        return message;
    },
    fromAmino(object) {
        return {
            pool: object?.pool ? (0, exports.PoolI_FromAmino)(object.pool) : undefined
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool = message.pool ? (0, exports.PoolI_ToAmino)(message.pool) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.PoolResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/pool-response",
            value: exports.PoolResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.PoolResponse.decode(message.value);
    },
    toProto(message) {
        return exports.PoolResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.PoolResponse",
            value: exports.PoolResponse.encode(message).finish()
        };
    }
};
function createBaseAllPoolsRequest() {
    return {};
}
exports.AllPoolsRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.AllPoolsRequest",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAllPoolsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseAllPoolsRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.AllPoolsRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/all-pools-request",
            value: exports.AllPoolsRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.AllPoolsRequest.decode(message.value);
    },
    toProto(message) {
        return exports.AllPoolsRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.AllPoolsRequest",
            value: exports.AllPoolsRequest.encode(message).finish()
        };
    }
};
function createBaseAllPoolsResponse() {
    return {
        pools: []
    };
}
exports.AllPoolsResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.AllPoolsResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pools) {
            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAllPoolsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pools.push((0, exports.PoolI_InterfaceDecoder)(reader));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseAllPoolsResponse();
        message.pools = object.pools?.map(e => any_1.Any.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            pools: Array.isArray(object?.pools) ? object.pools.map((e) => (0, exports.PoolI_FromAmino)(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.pools) {
            obj.pools = message.pools.map(e => e ? (0, exports.PoolI_ToAmino)(e) : undefined);
        }
        else {
            obj.pools = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.AllPoolsResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/all-pools-response",
            value: exports.AllPoolsResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.AllPoolsResponse.decode(message.value);
    },
    toProto(message) {
        return exports.AllPoolsResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.AllPoolsResponse",
            value: exports.AllPoolsResponse.encode(message).finish()
        };
    }
};
function createBaseSpotPriceRequest() {
    return {
        poolId: BigInt(0),
        baseAssetDenom: "",
        quoteAssetDenom: ""
    };
}
exports.SpotPriceRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.SpotPriceRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        if (message.baseAssetDenom !== "") {
            writer.uint32(18).string(message.baseAssetDenom);
        }
        if (message.quoteAssetDenom !== "") {
            writer.uint32(26).string(message.quoteAssetDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpotPriceRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                case 2:
                    message.baseAssetDenom = reader.string();
                    break;
                case 3:
                    message.quoteAssetDenom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseSpotPriceRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        message.baseAssetDenom = object.baseAssetDenom ?? "";
        message.quoteAssetDenom = object.quoteAssetDenom ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id),
            baseAssetDenom: object.base_asset_denom,
            quoteAssetDenom: object.quote_asset_denom
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        obj.base_asset_denom = message.baseAssetDenom;
        obj.quote_asset_denom = message.quoteAssetDenom;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.SpotPriceRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/spot-price-request",
            value: exports.SpotPriceRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.SpotPriceRequest.decode(message.value);
    },
    toProto(message) {
        return exports.SpotPriceRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.SpotPriceRequest",
            value: exports.SpotPriceRequest.encode(message).finish()
        };
    }
};
function createBaseSpotPriceResponse() {
    return {
        spotPrice: ""
    };
}
exports.SpotPriceResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.SpotPriceResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.spotPrice !== "") {
            writer.uint32(10).string(message.spotPrice);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpotPriceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spotPrice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseSpotPriceResponse();
        message.spotPrice = object.spotPrice ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            spotPrice: object.spot_price
        };
    },
    toAmino(message) {
        const obj = {};
        obj.spot_price = message.spotPrice;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.SpotPriceResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/spot-price-response",
            value: exports.SpotPriceResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.SpotPriceResponse.decode(message.value);
    },
    toProto(message) {
        return exports.SpotPriceResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.SpotPriceResponse",
            value: exports.SpotPriceResponse.encode(message).finish()
        };
    }
};
function createBaseTotalPoolLiquidityRequest() {
    return {
        poolId: BigInt(0)
    };
}
exports.TotalPoolLiquidityRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.TotalPoolLiquidityRequest",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.poolId !== BigInt(0)) {
            writer.uint32(8).uint64(message.poolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTotalPoolLiquidityRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTotalPoolLiquidityRequest();
        message.poolId = object.poolId !== undefined && object.poolId !== null ? BigInt(object.poolId.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            poolId: BigInt(object.pool_id)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool_id = message.poolId ? message.poolId.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TotalPoolLiquidityRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/total-pool-liquidity-request",
            value: exports.TotalPoolLiquidityRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.TotalPoolLiquidityRequest.decode(message.value);
    },
    toProto(message) {
        return exports.TotalPoolLiquidityRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.TotalPoolLiquidityRequest",
            value: exports.TotalPoolLiquidityRequest.encode(message).finish()
        };
    }
};
function createBaseTotalPoolLiquidityResponse() {
    return {
        liquidity: []
    };
}
exports.TotalPoolLiquidityResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.TotalPoolLiquidityResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.liquidity) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTotalPoolLiquidityResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidity.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTotalPoolLiquidityResponse();
        message.liquidity = object.liquidity?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            liquidity: Array.isArray(object?.liquidity) ? object.liquidity.map((e) => coin_1.Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.liquidity) {
            obj.liquidity = message.liquidity.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.liquidity = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TotalPoolLiquidityResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/total-pool-liquidity-response",
            value: exports.TotalPoolLiquidityResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.TotalPoolLiquidityResponse.decode(message.value);
    },
    toProto(message) {
        return exports.TotalPoolLiquidityResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.TotalPoolLiquidityResponse",
            value: exports.TotalPoolLiquidityResponse.encode(message).finish()
        };
    }
};
function createBaseTotalLiquidityRequest() {
    return {};
}
exports.TotalLiquidityRequest = {
    typeUrl: "/osmosis.poolmanager.v1beta1.TotalLiquidityRequest",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTotalLiquidityRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseTotalLiquidityRequest();
        return message;
    },
    fromAmino(_) {
        return {};
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TotalLiquidityRequest.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/total-liquidity-request",
            value: exports.TotalLiquidityRequest.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.TotalLiquidityRequest.decode(message.value);
    },
    toProto(message) {
        return exports.TotalLiquidityRequest.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.TotalLiquidityRequest",
            value: exports.TotalLiquidityRequest.encode(message).finish()
        };
    }
};
function createBaseTotalLiquidityResponse() {
    return {
        liquidity: []
    };
}
exports.TotalLiquidityResponse = {
    typeUrl: "/osmosis.poolmanager.v1beta1.TotalLiquidityResponse",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.liquidity) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTotalLiquidityResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidity.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTotalLiquidityResponse();
        message.liquidity = object.liquidity?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        return {
            liquidity: Array.isArray(object?.liquidity) ? object.liquidity.map((e) => coin_1.Coin.fromAmino(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.liquidity) {
            obj.liquidity = message.liquidity.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.liquidity = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TotalLiquidityResponse.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/poolmanager/total-liquidity-response",
            value: exports.TotalLiquidityResponse.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return exports.TotalLiquidityResponse.decode(message.value);
    },
    toProto(message) {
        return exports.TotalLiquidityResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.poolmanager.v1beta1.TotalLiquidityResponse",
            value: exports.TotalLiquidityResponse.encode(message).finish()
        };
    }
};
const PoolI_InterfaceDecoder = (input) => {
    const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
    const data = any_1.Any.decode(reader, reader.uint32());
    switch (data.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return pool_1.Pool.decode(data.value);
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return pool_2.CosmWasmPool.decode(data.value);
        case "/osmosis.gamm.v1beta1.Pool":
            return balancerPool_1.Pool.decode(data.value);
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return stableswap_pool_1.Pool.decode(data.value);
        default:
            return data;
    }
};
exports.PoolI_InterfaceDecoder = PoolI_InterfaceDecoder;
const PoolI_FromAmino = (content) => {
    switch (content.type) {
        case "osmosis/concentratedliquidity/pool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.concentratedliquidity.v1beta1.Pool",
                value: pool_1.Pool.encode(pool_1.Pool.fromPartial(pool_1.Pool.fromAmino(content.value))).finish()
            });
        case "osmosis/cosmwasmpool/cosm-wasm-pool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool",
                value: pool_2.CosmWasmPool.encode(pool_2.CosmWasmPool.fromPartial(pool_2.CosmWasmPool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/BalancerPool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.gamm.v1beta1.Pool",
                value: balancerPool_1.Pool.encode(balancerPool_1.Pool.fromPartial(balancerPool_1.Pool.fromAmino(content.value))).finish()
            });
        case "osmosis/gamm/StableswapPool":
            return any_1.Any.fromPartial({
                typeUrl: "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool",
                value: stableswap_pool_1.Pool.encode(stableswap_pool_1.Pool.fromPartial(stableswap_pool_1.Pool.fromAmino(content.value))).finish()
            });
        default:
            return any_1.Any.fromAmino(content);
    }
};
exports.PoolI_FromAmino = PoolI_FromAmino;
const PoolI_ToAmino = (content) => {
    switch (content.typeUrl) {
        case "/osmosis.concentratedliquidity.v1beta1.Pool":
            return {
                type: "osmosis/concentratedliquidity/pool",
                value: pool_1.Pool.toAmino(pool_1.Pool.decode(content.value))
            };
        case "/osmosis.cosmwasmpool.v1beta1.CosmWasmPool":
            return {
                type: "osmosis/cosmwasmpool/cosm-wasm-pool",
                value: pool_2.CosmWasmPool.toAmino(pool_2.CosmWasmPool.decode(content.value))
            };
        case "/osmosis.gamm.v1beta1.Pool":
            return {
                type: "osmosis/gamm/BalancerPool",
                value: balancerPool_1.Pool.toAmino(balancerPool_1.Pool.decode(content.value))
            };
        case "/osmosis.gamm.poolmodels.stableswap.v1beta1.Pool":
            return {
                type: "osmosis/gamm/StableswapPool",
                value: stableswap_pool_1.Pool.toAmino(stableswap_pool_1.Pool.decode(content.value))
            };
        default:
            return any_1.Any.toAmino(content);
    }
};
exports.PoolI_ToAmino = PoolI_ToAmino;
//# sourceMappingURL=query.js.map
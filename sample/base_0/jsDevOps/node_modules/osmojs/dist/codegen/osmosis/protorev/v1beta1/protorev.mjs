import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { BinaryReader, BinaryWriter } from "../../../binary";
function createBaseTokenPairArbRoutes() {
    return {
        arbRoutes: [],
        tokenIn: "",
        tokenOut: ""
    };
}
export const TokenPairArbRoutes = {
    typeUrl: "/osmosis.protorev.v1beta1.TokenPairArbRoutes",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.arbRoutes) {
            Route.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.tokenIn !== "") {
            writer.uint32(18).string(message.tokenIn);
        }
        if (message.tokenOut !== "") {
            writer.uint32(26).string(message.tokenOut);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenPairArbRoutes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.arbRoutes.push(Route.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.tokenIn = reader.string();
                    break;
                case 3:
                    message.tokenOut = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTokenPairArbRoutes();
        message.arbRoutes = object.arbRoutes?.map(e => Route.fromPartial(e)) || [];
        message.tokenIn = object.tokenIn ?? "";
        message.tokenOut = object.tokenOut ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            arbRoutes: Array.isArray(object?.arb_routes) ? object.arb_routes.map((e) => Route.fromAmino(e)) : [],
            tokenIn: object.token_in,
            tokenOut: object.token_out
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.arbRoutes) {
            obj.arb_routes = message.arbRoutes.map(e => e ? Route.toAmino(e) : undefined);
        }
        else {
            obj.arb_routes = [];
        }
        obj.token_in = message.tokenIn;
        obj.token_out = message.tokenOut;
        return obj;
    },
    fromAminoMsg(object) {
        return TokenPairArbRoutes.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/protorev/token-pair-arb-routes",
            value: TokenPairArbRoutes.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return TokenPairArbRoutes.decode(message.value);
    },
    toProto(message) {
        return TokenPairArbRoutes.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.protorev.v1beta1.TokenPairArbRoutes",
            value: TokenPairArbRoutes.encode(message).finish()
        };
    }
};
function createBaseRoute() {
    return {
        trades: [],
        stepSize: ""
    };
}
export const Route = {
    typeUrl: "/osmosis.protorev.v1beta1.Route",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.trades) {
            Trade.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.stepSize !== "") {
            writer.uint32(18).string(message.stepSize);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoute();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.trades.push(Trade.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.stepSize = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseRoute();
        message.trades = object.trades?.map(e => Trade.fromPartial(e)) || [];
        message.stepSize = object.stepSize ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            trades: Array.isArray(object?.trades) ? object.trades.map((e) => Trade.fromAmino(e)) : [],
            stepSize: object.step_size
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.trades) {
            obj.trades = message.trades.map(e => e ? Trade.toAmino(e) : undefined);
        }
        else {
            obj.trades = [];
        }
        obj.step_size = message.stepSize;
        return obj;
    },
    fromAminoMsg(object) {
        return Route.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/protorev/route",
            value: Route.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return Route.decode(message.value);
    },
    toProto(message) {
        return Route.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.protorev.v1beta1.Route",
            value: Route.encode(message).finish()
        };
    }
};
function createBaseTrade() {
    return {
        pool: BigInt(0),
        tokenIn: "",
        tokenOut: ""
    };
}
export const Trade = {
    typeUrl: "/osmosis.protorev.v1beta1.Trade",
    encode(message, writer = BinaryWriter.create()) {
        if (message.pool !== BigInt(0)) {
            writer.uint32(8).uint64(message.pool);
        }
        if (message.tokenIn !== "") {
            writer.uint32(18).string(message.tokenIn);
        }
        if (message.tokenOut !== "") {
            writer.uint32(26).string(message.tokenOut);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrade();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = reader.uint64();
                    break;
                case 2:
                    message.tokenIn = reader.string();
                    break;
                case 3:
                    message.tokenOut = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseTrade();
        message.pool = object.pool !== undefined && object.pool !== null ? BigInt(object.pool.toString()) : BigInt(0);
        message.tokenIn = object.tokenIn ?? "";
        message.tokenOut = object.tokenOut ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            pool: BigInt(object.pool),
            tokenIn: object.token_in,
            tokenOut: object.token_out
        };
    },
    toAmino(message) {
        const obj = {};
        obj.pool = message.pool ? message.pool.toString() : undefined;
        obj.token_in = message.tokenIn;
        obj.token_out = message.tokenOut;
        return obj;
    },
    fromAminoMsg(object) {
        return Trade.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/protorev/trade",
            value: Trade.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return Trade.decode(message.value);
    },
    toProto(message) {
        return Trade.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.protorev.v1beta1.Trade",
            value: Trade.encode(message).finish()
        };
    }
};
function createBaseRouteStatistics() {
    return {
        profits: [],
        numberOfTrades: "",
        route: []
    };
}
export const RouteStatistics = {
    typeUrl: "/osmosis.protorev.v1beta1.RouteStatistics",
    encode(message, writer = BinaryWriter.create()) {
        for (const v of message.profits) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.numberOfTrades !== "") {
            writer.uint32(18).string(message.numberOfTrades);
        }
        writer.uint32(26).fork();
        for (const v of message.route) {
            writer.uint64(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRouteStatistics();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.profits.push(Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.numberOfTrades = reader.string();
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.route.push(reader.uint64());
                        }
                    }
                    else {
                        message.route.push(reader.uint64());
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseRouteStatistics();
        message.profits = object.profits?.map(e => Coin.fromPartial(e)) || [];
        message.numberOfTrades = object.numberOfTrades ?? "";
        message.route = object.route?.map(e => BigInt(e.toString())) || [];
        return message;
    },
    fromAmino(object) {
        return {
            profits: Array.isArray(object?.profits) ? object.profits.map((e) => Coin.fromAmino(e)) : [],
            numberOfTrades: object.number_of_trades,
            route: Array.isArray(object?.route) ? object.route.map((e) => BigInt(e)) : []
        };
    },
    toAmino(message) {
        const obj = {};
        if (message.profits) {
            obj.profits = message.profits.map(e => e ? Coin.toAmino(e) : undefined);
        }
        else {
            obj.profits = [];
        }
        obj.number_of_trades = message.numberOfTrades;
        if (message.route) {
            obj.route = message.route.map(e => e.toString());
        }
        else {
            obj.route = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return RouteStatistics.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/protorev/route-statistics",
            value: RouteStatistics.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return RouteStatistics.decode(message.value);
    },
    toProto(message) {
        return RouteStatistics.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.protorev.v1beta1.RouteStatistics",
            value: RouteStatistics.encode(message).finish()
        };
    }
};
function createBasePoolWeights() {
    return {
        stableWeight: BigInt(0),
        balancerWeight: BigInt(0),
        concentratedWeight: BigInt(0)
    };
}
export const PoolWeights = {
    typeUrl: "/osmosis.protorev.v1beta1.PoolWeights",
    encode(message, writer = BinaryWriter.create()) {
        if (message.stableWeight !== BigInt(0)) {
            writer.uint32(8).uint64(message.stableWeight);
        }
        if (message.balancerWeight !== BigInt(0)) {
            writer.uint32(16).uint64(message.balancerWeight);
        }
        if (message.concentratedWeight !== BigInt(0)) {
            writer.uint32(24).uint64(message.concentratedWeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePoolWeights();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stableWeight = reader.uint64();
                    break;
                case 2:
                    message.balancerWeight = reader.uint64();
                    break;
                case 3:
                    message.concentratedWeight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBasePoolWeights();
        message.stableWeight = object.stableWeight !== undefined && object.stableWeight !== null ? BigInt(object.stableWeight.toString()) : BigInt(0);
        message.balancerWeight = object.balancerWeight !== undefined && object.balancerWeight !== null ? BigInt(object.balancerWeight.toString()) : BigInt(0);
        message.concentratedWeight = object.concentratedWeight !== undefined && object.concentratedWeight !== null ? BigInt(object.concentratedWeight.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        return {
            stableWeight: BigInt(object.stable_weight),
            balancerWeight: BigInt(object.balancer_weight),
            concentratedWeight: BigInt(object.concentrated_weight)
        };
    },
    toAmino(message) {
        const obj = {};
        obj.stable_weight = message.stableWeight ? message.stableWeight.toString() : undefined;
        obj.balancer_weight = message.balancerWeight ? message.balancerWeight.toString() : undefined;
        obj.concentrated_weight = message.concentratedWeight ? message.concentratedWeight.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return PoolWeights.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/protorev/pool-weights",
            value: PoolWeights.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return PoolWeights.decode(message.value);
    },
    toProto(message) {
        return PoolWeights.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.protorev.v1beta1.PoolWeights",
            value: PoolWeights.encode(message).finish()
        };
    }
};
function createBaseBaseDenom() {
    return {
        denom: "",
        stepSize: ""
    };
}
export const BaseDenom = {
    typeUrl: "/osmosis.protorev.v1beta1.BaseDenom",
    encode(message, writer = BinaryWriter.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.stepSize !== "") {
            writer.uint32(18).string(message.stepSize);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBaseDenom();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.stepSize = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseBaseDenom();
        message.denom = object.denom ?? "";
        message.stepSize = object.stepSize ?? "";
        return message;
    },
    fromAmino(object) {
        return {
            denom: object.denom,
            stepSize: object.step_size
        };
    },
    toAmino(message) {
        const obj = {};
        obj.denom = message.denom;
        obj.step_size = message.stepSize;
        return obj;
    },
    fromAminoMsg(object) {
        return BaseDenom.fromAmino(object.value);
    },
    toAminoMsg(message) {
        return {
            type: "osmosis/protorev/base-denom",
            value: BaseDenom.toAmino(message)
        };
    },
    fromProtoMsg(message) {
        return BaseDenom.decode(message.value);
    },
    toProto(message) {
        return BaseDenom.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/osmosis.protorev.v1beta1.BaseDenom",
            value: BaseDenom.encode(message).finish()
        };
    }
};
//# sourceMappingURL=protorev.js.map